(window.webpackJsonp=window.webpackJsonp||[]).push([[650],{1347:function(t,s,a){"use strict";a.r(s);var e=a(5),r=Object(e.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"redis-持久化机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redis-持久化机制"}},[t._v("#")]),t._v(" Redis 持久化机制")]),t._v(" "),a("p",[t._v("Redis 有两种持久化机制：")]),t._v(" "),a("h2",{attrs:{id:"rdb"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#rdb"}},[t._v("#")]),t._v(" RDB")]),t._v(" "),a("p",[t._v("RDB 持久化方式会在一个特定的间隔保存那个时间点的一个数据快照")]),t._v(" "),a("h2",{attrs:{id:"aof"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#aof"}},[t._v("#")]),t._v(" AOF")]),t._v(" "),a("p",[t._v("AOF 持久化方式则会记录每一个服务器收到的写操作。在服务启动时，这些记录的操作会逐条执行从而重建出原来的数据。写操作命令记录的格式跟 Redis 协议一致，以追加的方式进行保存")]),t._v(" "),a("p",[t._v("Redis 的持久化是可以禁用的，就是说你可以让数据的生命周期只存在于服务器的运行时间里。两种方式的持久化是可以同时存在的，但是当 Redis 重启时，AOF 文件会被优先用于重建数据。")])])}),[],!1,null,null,null);s.default=r.exports}}]);