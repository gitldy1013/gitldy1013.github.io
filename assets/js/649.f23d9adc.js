(window.webpackJsonp=window.webpackJsonp||[]).push([[649],{1346:function(e,t,s){"use strict";s.r(t);var i=s(5),r=Object(i.a)({},(function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h1",{attrs:{id:"redis-内部结构"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#redis-内部结构"}},[e._v("#")]),e._v(" Redis 内部结构")]),e._v(" "),s("p",[e._v("Redis 内部使用一个 redisObject 对象来表示所有的 key 和 value。")]),e._v(" "),s("ul",[s("li",[e._v("type ：代表一个 value 对象具体是何种数据类型。")]),e._v(" "),s("li",[e._v('encoding ：是不同数据类型在 redis 内部的存储方式，比如：type=string 代表 value 存储的是一个普通字符串，那么对应的 encoding 可以是 raw 或者是 int，如果是 int 则代表实际 redis 内部是按数值型类存储和表示这个字符串的，当然前提是这个字符串本身可以用数值表示，比如："123" "456"这样的字符串。')]),e._v(" "),s("li",[e._v("vm 字段：只有打开了 Redis 的虚拟内存功能，此字段才会真正的分配内存，该功能默认是关闭状态的。 Redis 使用 redisObject 来表示所有的 key/value 数据是比较浪费内存的，当然这些内存管理成本的付出主要也是为了给 Redis 不同数据类型提供一个统一的管理接口，实际作者也提供了多种方法帮助我们尽量节省内存使用。")])])])}),[],!1,null,null,null);t.default=r.exports}}]);