(window.webpackJsonp=window.webpackJsonp||[]).push([[1035],{1731:function(t,n,e){"use strict";e.r(n);var r=e(5),o=Object(r.a)({},(function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"spring-与-ioc"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#spring-与-ioc"}},[t._v("#")]),t._v(" Spring 与 IoC")]),t._v(" "),e("h2",{attrs:{id:"概述"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#概述"}},[t._v("#")]),t._v(" 概述")]),t._v(" "),e("p",[t._v("控制反转（IoC，Inversion of Control），是一个概念，是一种思想。指将传统上由程序代码直接操控的对象调用权交给容器，通过容器来实现对象的装配和管理。控制反转就是对对象控制权的转移，从程序代码本身反转到了外部容器。")]),t._v(" "),e("p",[t._v("IoC 是一个概念，是一种思想，其实现方式多种多样。当前比较流行的实现方式有两种： 依赖注入和依赖查找。依赖注入方式应用更为广泛。")]),t._v(" "),e("ul",[e("li",[t._v("依赖查找：Dependency Lookup，DL，容器提供回调接口和上下文环境给组件，程序代码则需要提供具体的查找方式。比较典型的是依赖于 JNDI 系统的查找。")]),t._v(" "),e("li",[t._v("**依赖注入：**Dependency Injection，DI，程序代码不做定位查询，这些工作由容器自行完成。")])]),t._v(" "),e("p",[t._v("依赖注入 DI 是指程序运行过程中，若需要调用另一个对象协助时，无须在代码中创建被调用者，而是依赖于外部容器，由外部容器创建后传递给程序。")]),t._v(" "),e("p",[t._v("Spring 的依赖注入对调用者与被调用者几乎没有任何要求，完全支持 POJO 之间依赖关系的管理。")]),t._v(" "),e("p",[e("strong",[t._v("依赖注入是目前最优秀的解耦方式")]),t._v("。依赖注入让 Spring 的 Bean 之间以配置文件的方式组织在一起，而不是以硬编码的方式耦合在一起的。")])])}),[],!1,null,null,null);n.default=o.exports}}]);