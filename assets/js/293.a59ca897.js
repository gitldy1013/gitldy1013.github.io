(window.webpackJsonp=window.webpackJsonp||[]).push([[293],{989:function(a,s,t){"use strict";t.r(s);var e=t(5),n=Object(e.a)({},(function(){var a=this,s=a.$createElement,t=a._self._c||s;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"volatile禁止指令重排"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#volatile禁止指令重排"}},[a._v("#")]),a._v(" Volatile禁止指令重排")]),a._v(" "),t("p",[a._v("计算机在执行程序时，为了提高性能，编译器和处理器常常会对指令重排，一般分为以下三种：")]),a._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("源代码 -> 编译器优化的重排 -> 指令并行的重排 -> 内存系统的重排 -> 最终执行指令\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br")])]),t("p",[a._v("单线程环境里面确保最终执行结果和代码顺序的结果一致")]),a._v(" "),t("p",[a._v("处理器在进行重排序时，必须要考虑指令之间的"),t("code",[a._v("数据依赖性")])]),a._v(" "),t("p",[a._v("多线程环境中线程交替执行，由于编译器优化重排的存在，两个线程中使用的变量能否保证一致性是无法确定的，结果无法预测。")]),a._v(" "),t("h2",{attrs:{id:"指令重排-example-1"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#指令重排-example-1"}},[a._v("#")]),a._v(" 指令重排 - example 1")]),a._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("public void mySort() {\n\tint x = 11;\n\tint y = 12;\n\tx = x + 5;\n\ty = x * x;\n}\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br"),t("span",{staticClass:"line-number"},[a._v("3")]),t("br"),t("span",{staticClass:"line-number"},[a._v("4")]),t("br"),t("span",{staticClass:"line-number"},[a._v("5")]),t("br"),t("span",{staticClass:"line-number"},[a._v("6")]),t("br")])]),t("p",[a._v("按照正常单线程环境，执行顺序是 1 2 3 4")]),a._v(" "),t("p",[a._v("但是在多线程环境下，可能出现以下的顺序：")]),a._v(" "),t("ul",[t("li",[a._v("2 1 3 4")]),a._v(" "),t("li",[a._v("1 3 2 4")])]),a._v(" "),t("p",[a._v("上述的过程就可以当做是指令的重排，即内部执行顺序，和我们的代码顺序不一样")]),a._v(" "),t("p",[a._v("但是指令重排也是有限制的，即不会出现下面的顺序")]),a._v(" "),t("ul",[t("li",[a._v("4 3 2 1")])]),a._v(" "),t("p",[a._v("因为处理器在进行重排时候，必须考虑到指令之间的数据依赖性")]),a._v(" "),t("p",[a._v("因为步骤 4：需要依赖于 y的申明，以及x的申明，故因为存在数据依赖，无法首先执行")]),a._v(" "),t("h3",{attrs:{id:"例子"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#例子"}},[a._v("#")]),a._v(" 例子")]),a._v(" "),t("p",[a._v("int a,b,x,y = 0")]),a._v(" "),t("table",[t("thead",[t("tr",[t("th",[a._v("线程1")]),a._v(" "),t("th",[a._v("线程2")])])]),a._v(" "),t("tbody",[t("tr",[t("td",[a._v("x = a;")]),a._v(" "),t("td",[a._v("y = b;")])]),a._v(" "),t("tr",[t("td",[a._v("b = 1;")]),a._v(" "),t("td",[a._v("a = 2;")])]),a._v(" "),t("tr",[t("td"),a._v(" "),t("td")]),a._v(" "),t("tr",[t("td",[a._v("x = 0;  y = 0")]),a._v(" "),t("td")])])]),a._v(" "),t("p",[a._v("因为上面的代码，不存在数据的依赖性，因此编译器可能对数据进行重排")]),a._v(" "),t("table",[t("thead",[t("tr",[t("th",[a._v("线程1")]),a._v(" "),t("th",[a._v("线程2")])])]),a._v(" "),t("tbody",[t("tr",[t("td",[a._v("b = 1;")]),a._v(" "),t("td",[a._v("a = 2;")])]),a._v(" "),t("tr",[t("td",[a._v("x = a;")]),a._v(" "),t("td",[a._v("y = b;")])]),a._v(" "),t("tr",[t("td"),a._v(" "),t("td")]),a._v(" "),t("tr",[t("td",[a._v("x = 2;  y = 1")]),a._v(" "),t("td")])])]),a._v(" "),t("p",[a._v("这样造成的结果，和最开始的就不一致了，这就是导致重排后，结果和最开始的不一样，因此为了防止这种结果出现，volatile就规定禁止指令重排，为了保证数据的一致性")]),a._v(" "),t("h2",{attrs:{id:"指令重排-example-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#指令重排-example-2"}},[a._v("#")]),a._v(" 指令重排 - example 2")]),a._v(" "),t("p",[a._v("比如下面这段代码")]),a._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v('/**\n * ResortSeqDemo\n *\n * @author: 陌溪\n * @create: 2020-03-10-16:08\n */\npublic class ResortSeqDemo {\n    int a= 0;\n    boolean flag = false;\n\n    public void method01() {\n        a = 1;\n        flag = true;\n    }\n\n    public void method02() {\n        if(flag) {\n            a = a + 5;\n            System.out.println("reValue:" + a);\n        }\n    }\n}\n')])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br"),t("span",{staticClass:"line-number"},[a._v("3")]),t("br"),t("span",{staticClass:"line-number"},[a._v("4")]),t("br"),t("span",{staticClass:"line-number"},[a._v("5")]),t("br"),t("span",{staticClass:"line-number"},[a._v("6")]),t("br"),t("span",{staticClass:"line-number"},[a._v("7")]),t("br"),t("span",{staticClass:"line-number"},[a._v("8")]),t("br"),t("span",{staticClass:"line-number"},[a._v("9")]),t("br"),t("span",{staticClass:"line-number"},[a._v("10")]),t("br"),t("span",{staticClass:"line-number"},[a._v("11")]),t("br"),t("span",{staticClass:"line-number"},[a._v("12")]),t("br"),t("span",{staticClass:"line-number"},[a._v("13")]),t("br"),t("span",{staticClass:"line-number"},[a._v("14")]),t("br"),t("span",{staticClass:"line-number"},[a._v("15")]),t("br"),t("span",{staticClass:"line-number"},[a._v("16")]),t("br"),t("span",{staticClass:"line-number"},[a._v("17")]),t("br"),t("span",{staticClass:"line-number"},[a._v("18")]),t("br"),t("span",{staticClass:"line-number"},[a._v("19")]),t("br"),t("span",{staticClass:"line-number"},[a._v("20")]),t("br"),t("span",{staticClass:"line-number"},[a._v("21")]),t("br"),t("span",{staticClass:"line-number"},[a._v("22")]),t("br")])]),t("p",[a._v("我们按照正常的顺序，分别调用method01()  和 method02() 那么，最终输出就是 a = 6")]),a._v(" "),t("p",[a._v("但是如果在多线程环境下，因为方法1 和 方法2，他们之间不能存在数据依赖的问题，因此原先的顺序可能是")]),a._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v('a = 1;\nflag = true;\n\na = a + 5;\nSystem.out.println("reValue:" + a);\n        \n')])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br"),t("span",{staticClass:"line-number"},[a._v("3")]),t("br"),t("span",{staticClass:"line-number"},[a._v("4")]),t("br"),t("span",{staticClass:"line-number"},[a._v("5")]),t("br"),t("span",{staticClass:"line-number"},[a._v("6")]),t("br")])]),t("p",[a._v("但是在经过编译器，指令，或者内存的重排后，可能会出现这样的情况")]),a._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v('flag = true;\n\na = a + 5;\nSystem.out.println("reValue:" + a);\n\na = 1;\n')])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br"),t("span",{staticClass:"line-number"},[a._v("3")]),t("br"),t("span",{staticClass:"line-number"},[a._v("4")]),t("br"),t("span",{staticClass:"line-number"},[a._v("5")]),t("br"),t("span",{staticClass:"line-number"},[a._v("6")]),t("br")])]),t("p",[a._v("也就是先执行 flag = true后，另外一个线程马上调用方法2，满足 flag的判断，最终让a + 5，结果为5，这样同样出现了数据不一致的问题")]),a._v(" "),t("p",[a._v("为什么会出现这个结果：多线程环境中线程交替执行，由于编译器优化重排的存在，两个线程中使用的变量能否保证一致性是无法确定的，结果无法预测。")]),a._v(" "),t("p",[a._v("这样就需要通过volatile来修饰，来保证线程安全性")]),a._v(" "),t("h2",{attrs:{id:"volatile针对指令重排做了啥"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#volatile针对指令重排做了啥"}},[a._v("#")]),a._v(" Volatile针对指令重排做了啥")]),a._v(" "),t("p",[a._v("Volatile实现禁止指令重排优化，从而避免了多线程环境下程序出现乱序执行的现象")]),a._v(" "),t("p",[a._v("首先了解一个概念，内存屏障（Memory Barrier）又称内存栅栏，是一个CPU指令，它的作用有两个：")]),a._v(" "),t("ul",[t("li",[a._v("保证特定操作的顺序")]),a._v(" "),t("li",[a._v("保证某些变量的内存可见性（利用该特性实现volatile的内存可见性）")])]),a._v(" "),t("p",[a._v("由于编译器和处理器都能执行指令重排的优化，如果在指令间插入一条Memory Barrier则会告诉编译器和CPU，不管什么指令都不能和这条Memory Barrier指令重排序，也就是说 "),t("code",[a._v("通过插入内存屏障禁止在内存屏障前后的指令执行重排序优化")]),a._v("。 内存屏障另外一个作用是刷新出各种CPU的缓存数，因此任何CPU上的线程都能读取到这些数据的最新版本。")]),a._v(" "),t("p",[t("img",{attrs:{src:"/images/image-20200310162654437.png",alt:"image-20200310162654437"}})]),a._v(" "),t("p",[a._v("也就是过在Volatile的写 和 读的时候，加入屏障，防止出现指令重排的")]),a._v(" "),t("h2",{attrs:{id:"线程安全获得保证"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#线程安全获得保证"}},[a._v("#")]),a._v(" 线程安全获得保证")]),a._v(" "),t("p",[a._v("工作内存与主内存同步延迟现象导致的可见性问题")]),a._v(" "),t("ul",[t("li",[a._v("可通过synchronized或volatile关键字解决，他们都可以使一个线程修改后的变量立即对其它线程可见")])]),a._v(" "),t("p",[a._v("对于指令重排导致的可见性问题和有序性问题")]),a._v(" "),t("ul",[t("li",[a._v("可以使用volatile关键字解决，因为volatile关键字的另一个作用就是禁止重排序优化")])]),a._v(" "),t("h2",{attrs:{id:"总线嗅探"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#总线嗅探"}},[a._v("#")]),a._v(" 总线嗅探")])])}),[],!1,null,null,null);s.default=n.exports}}]);