(window.webpackJsonp=window.webpackJsonp||[]).push([[618],{1315:function(e,n,r){"use strict";r.r(n);var t=r(5),a=Object(t.a)({},(function(){var e=this,n=e.$createElement,r=e._self._c||n;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h1",{attrs:{id:"java中的并发工具类"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#java中的并发工具类"}},[e._v("#")]),e._v(" Java中的并发工具类")]),e._v(" "),r("p",[e._v("在JDK的并发包里提供了几个非常有用的并发工具类。CountDownLatch、CyclicBarrier和Semaphore工具类提供了一种并发流程控制的手段，Exchanger工具类则提供了在线程间交换数据的一种手段。本章会配合一些应用场景来介绍如何使用这些工具类。")]),e._v(" "),r("h2",{attrs:{id:"等待多线程完成的countdownlatch"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#等待多线程完成的countdownlatch"}},[e._v("#")]),e._v(" 等待多线程完成的CountDownLatch")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",[r("code",[e._v("public class CountDownLatchTest {\n\n    static CountDownLatch c = new CountDownLatch(2);\n\n    public static void main(String[] args) {\n        new Thread(new Runnable() {\n            @Override\n            public void run() {\n                System.out.println(1);\n                c.countDown();\n                System.out.println(2);\n                c.countDown();\n            }\n        }).start();\n        System.out.println(3);\n    }\n}\n")])])]),r("p",[e._v("CountDownLatch的构造函数接收一个int类型的参数作为计数器，如果你想等待N个点完成，这里就传入N。")]),e._v(" "),r("p",[e._v("当我们调用CountDownLatch的countDown方法时，N就会减1，CountDownLatch的await方法会阻塞当前线程，直到N变成零。由于countDown方法可以用在任何地方，所以这里说的N个点，可以是N个线程，也可以是1个线程里的N个执行步骤。用在多个线程时，只需要把这个CountDownLatch的引用传递到线程里即可。")]),e._v(" "),r("h2",{attrs:{id:"同步屏障cyclicbarrier"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#同步屏障cyclicbarrier"}},[e._v("#")]),e._v(" 同步屏障CyclicBarrier")]),e._v(" "),r("p",[e._v("CyclicBarrier的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续运行。")]),e._v(" "),r("h2",{attrs:{id:"cyclicbarrier简介"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#cyclicbarrier简介"}},[e._v("#")]),e._v(" CyclicBarrier简介")]),e._v(" "),r("p",[e._v("CyclicBarrier默认的构造方法是CyclicBarrier（int parties），其参数表示屏障拦截的线程数量，每个线程调用await方法告诉CyclicBarrier我已经到达了屏障，然后当前线程被阻塞。示例代码如代码清单8-3所示。")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",[r("code",[e._v("public class CyclicBarrierTest {\n    static CyclicBarrier c = new CyclicBarrier(2);\n\n    public static void main(String[] args) {\n        new Thread(new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    c.await();\n                } catch (Exception e) {\n                    e.printStackTrace();\n                } \n                System.out.println(1);\n            }\n        }).start();\n        try {\n            c.await();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }  \n        System.out.println(2);\n    }\n}\n")])])]),r("p",[e._v("因为主线程和子线程的调度是由CPU决定的，两个线程都有可能先执行，所以会产生两种输出，第一种可能输出如下。")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",[r("code",[e._v("1\n2\n")])])]),r("p",[e._v("第二种可能输出如下。")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",[r("code",[e._v("2\n1\n")])])]),r("p",[e._v("如果把new CyclicBarrier(2)修改成new CyclicBarrier(3)，则主线程和子线程会永远等待，因为没有第三个线程执行await方法，即没有第三个线程到达屏障，所以之前到达屏障的两个线程都不会继续执行。")]),e._v(" "),r("p",[e._v("CyclicBarrier还提供一个更高级的构造函数CyclicBarrier（int parties，Runnable barrier-Action），用于在线程到达屏障时，优先执行barrierAction，方便处理更复杂的业务场景")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",[r("code",[e._v("public class CyclicBarrierTest2 {\n    static CyclicBarrier c = new CyclicBarrier(2,new A());\n\n    public static void main(String[] args) {\n        new Thread(new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    c.await();\n                } catch (Exception e) {\n                }\n                System.out.println(1);\n            }\n        }).start();\n        try {\n            c.await();\n        } catch (Exception e) {\n        }\n        System.out.println(2);\n    }\n\n    static class A implements Runnable {\n        @Override\n        public void run() {\n            System.out.println(3);\n        }\n    }\n}\n")])])]),r("p",[e._v("因为CyclicBarrier设置了拦截线程的数量是2，所以必须等代码中的第一个线程和线程A都执行完之后，才会继续执行主线程，然后输出2，所以代码执行后的输出如下。")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",[r("code",[e._v("3\n1\n2\n")])])]),r("h2",{attrs:{id:"cyclicbarrier的应用场景"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#cyclicbarrier的应用场景"}},[e._v("#")]),e._v(" CyclicBarrier的应用场景")]),e._v(" "),r("p",[e._v("CyclicBarrier可以用于多线程计算数据，最后合并计算结果的场景。例如，用一个Excel保存了用户所有银行流水，每个Sheet保存一个账户近一年的每笔银行流水，现在需要统计用户的日均银行流水，先用多线程处理每个sheet里的银行流水，都执行完之后，得到每个sheet的日均银行流水，最后，再用barrierAction用这些线程的计算结果，计算出整个Excel的日均银行流水，如代码清单8-5所示。")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",[r("code",[e._v('public class BankWaterService implements Runnable{\n\n    /**\n     * 创建4个屏障，处理完之后执行当前类的run方法\n     */\n    private CyclicBarrier c = new CyclicBarrier(4, this);\n    /**\n     * 假设只有4个sheet，所以只启动4个线程\n     */\n    private Executor executor = Executors.newFixedThreadPool(4);\n    /**\n     * 保存每个sheet计算出的银流结果\n     */\n    private ConcurrentHashMap<String, Integer>sheetBankWaterCount = new ConcurrentHashMap<String, Integer>();\n    private void count(){\n        for (int i = 0; i < 4; i++) {\n            executor.execute(new Runnable() {\n                @Override\n                public void run() {\n                    // 计算当前sheet的银流数据，计算代码省略\n                    sheetBankWaterCount.put(Thread.currentThread().getName(), 1);\n                    // 银流计算完成，插入一个屏障\n                    try {\n                        c.await();\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    } catch (BrokenBarrierException e) {\n                        e.printStackTrace();\n                    }\n                }\n            });\n        }\n    }\n\n    @Override\n    public void run() {\n        int result = 0;\n        for (Map.Entry<String, Integer> sheet : sheetBankWaterCount.entrySet()) {\n            result += sheet.getValue();\n        }\n        sheetBankWaterCount.put("result", result);\n        System.out.println(result);\n    }\n\n    public static void main(String[] args) {\n        BankWaterService bankWaterService = new BankWaterService();\n        bankWaterService.count();\n    }\n}\n')])])]),r("p",[e._v("使用线程池创建4个线程，分别计算每个sheet里的数据，每个sheet计算结果是1，再由BankWaterService线程汇总4个sheet计算出的结果，输出结果如下。")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",[r("code",[e._v("4\n")])])]),r("h2",{attrs:{id:"cyclicbarrier和countdownlatch的区别"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#cyclicbarrier和countdownlatch的区别"}},[e._v("#")]),e._v(" CyclicBarrier和CountDownLatch的区别")]),e._v(" "),r("p",[e._v("CountDownLatch的计数器只能使用一次，而CyclicBarrier的计数器可以使用reset()方法重置。所以CyclicBarrier能处理更为复杂的业务场景。例如，如果计算发生错误，可以重置计数器，并让线程重新执行一次。")]),e._v(" "),r("p",[e._v("CyclicBarrier还提供其他有用的方法，比如getNumberWaiting方法可以获得Cyclic-Barrier阻塞的线程数量。isBroken()方法用来了解阻塞的线程是否被中断")]),e._v(" "),r("h2",{attrs:{id:"控制并发线程数的semaphore"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#控制并发线程数的semaphore"}},[e._v("#")]),e._v(" 控制并发线程数的Semaphore")]),e._v(" "),r("p",[e._v("Semaphore（信号量）是用来控制同时访问特定资源的线程数量，它通过协调各个线程，以保证合理的使用公共资源。")]),e._v(" "),r("h2",{attrs:{id:"应用场景"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#应用场景"}},[e._v("#")]),e._v(" 应用场景")]),e._v(" "),r("p",[e._v("Semaphore可以用于做流量控制，特别是公用资源有限的应用场景，比如数据库连接。假如有一个需求，要读取几万个文件的数据，因为都是IO密集型任务，我们可以启动几十个线程并发地读取，但是如果读到内存后，还需要存储到数据库中，而数据库的连接数只有10个，这时我们必须控制只有10个线程同时获取数据库连接保存数据，否则会报错无法获取数据库连接。这个时候，就可以使用Semaphore来做流量控制")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",[r("code",[e._v('public class SemaphoreTest {\n    private static final int THREAD_COUNT = 30;\n    private static ExecutorService threadPool = Executors.newFixedThreadPool(THREAD_COUNT);\n\n    private static Semaphore s = new Semaphore(10);\n\n    public static void main(String[] args) {\n        for (int i = 0; i <THREAD_COUNT ; i++) {\n            threadPool.execute(new Runnable() {\n                @Override\n                public void run() {\n                    try {\n                        s.acquire();\n                        System.out.println("save data");\n                        s.release();\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                    \n                }\n            });\n        }\n        threadPool.shutdown();\n    }\n}\n')])])]),r("p",[e._v("在代码中，虽然有30个线程在执行，但是只允许10个并发执行。Semaphore的构造方法Semaphore（int permits）接受一个整型的数字，表示可用的许可证数量。Semaphore（10）表示允许10个线程获取许可证，也就是最大并发数是10。Semaphore的用法也很简单，首先线程使用Semaphore的acquire()方法获取一个许可证，使用完之后调用release()方法归还许可证。还可以用tryAcquire()方法尝试获取许可证。")]),e._v(" "),r("p",[e._v("Semaphore还提供一些其他方法，具体如下。"),r("br"),e._v("\n·intavailablePermits()：返回此信号量中当前可用的许可证数。"),r("br"),e._v("\n·intgetQueueLength()：返回正在等待获取许可证的线程数。"),r("br"),e._v("\n·booleanhasQueuedThreads()：是否有线程正在等待获取许可证。"),r("br"),e._v("\n·void reducePermits（int reduction）：减少reduction个许可证，是个protected方法。"),r("br"),e._v("\n·Collection getQueuedThreads()：返回所有等待获取许可证的线程集合，是个protected方法。")])])}),[],!1,null,null,null);n.default=a.exports}}]);