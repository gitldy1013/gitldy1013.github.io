(window.webpackJsonp=window.webpackJsonp||[]).push([[272],{969:function(t,s,r){"use strict";r.r(s);var a=r(5),e=Object(a.a)({},(function(){var t=this,s=t.$createElement,r=t._self._c||s;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"kmp算法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#kmp算法"}},[t._v("#")]),t._v(" KMP算法")]),t._v(" "),r("h2",{attrs:{id:"字符串匹配问题"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#字符串匹配问题"}},[t._v("#")]),t._v(" 字符串匹配问题")]),t._v(" "),r("p",[t._v("字符串匹配问题场景")]),t._v(" "),r("ul",[r("li",[t._v('有一个字符串str1 = "abcdefg"  和 str2 = "def"')]),t._v(" "),r("li",[t._v("现在要判断str1 是否含有str2，如果存在，就返回第一次出现的位置，如果没有，则返回-1")])]),t._v(" "),r("h3",{attrs:{id:"暴力匹配算法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#暴力匹配算法"}},[t._v("#")]),t._v(" 暴力匹配算法")]),t._v(" "),r("p",[t._v("如果用暴力匹配的思路，并假设现在str1 匹配到i位置，字符串str2匹配到j位置，则有：")]),t._v(" "),r("ul",[r("li",[t._v("如果当前字符串匹配成功（即 str1[i] == str2[j]） , 则 i++，j++，继续匹配下一个字符")]),t._v(" "),r("li",[t._v("如果匹配失败（即 str1[i] != str2[j]），令 i = i - ( j - 1)，j = 0。相当于每次匹配失败时，i回溯，j被置为0.")]),t._v(" "),r("li",[t._v("用暴力方法解决的话，就会有大量的回溯，每次只移动一位，若匹配不成功，移动到下一位接着判断，浪费了大量的时间。")]),t._v(" "),r("li")])])}),[],!1,null,null,null);s.default=e.exports}}]);