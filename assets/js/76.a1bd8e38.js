(window.webpackJsonp=window.webpackJsonp||[]).push([[76],{773:function(v,_,a){"use strict";a.r(_);var i=a(5),t=Object(i.a)({},(function(){var v=this,_=v.$createElement,a=v._self._c||_;return a("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[a("h1",{attrs:{id:"go-zero架构设计"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#go-zero架构设计"}},[v._v("#")]),v._v(" go-zero架构设计")]),v._v(" "),a("h2",{attrs:{id:"来源"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#来源"}},[v._v("#")]),v._v(" 来源")]),v._v(" "),a("p",[a("a",{attrs:{href:"https://www.bilibili.com/video/BV1rD4y127PD/",target:"_blank",rel:"noopener noreferrer"}},[v._v("晓黑板 go-zero 微服务框架的架构设计"),a("OutboundLink")],1)]),v._v(" "),a("p",[v._v("晓黑板为例 打算做日活千万的项目")]),v._v(" "),a("h2",{attrs:{id:"架构设计的几点思考"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#架构设计的几点思考"}},[v._v("#")]),v._v(" 架构设计的几点思考")]),v._v(" "),a("ul",[a("li",[v._v("架构设计不能脱离业务")]),v._v(" "),a("li",[v._v("能够快速迭代")]),v._v(" "),a("li",[v._v("PHP？Java or Golang？")]),v._v(" "),a("li",[v._v("开源 or 自研？")])]),v._v(" "),a("h2",{attrs:{id:"设计原则"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#设计原则"}},[v._v("#")]),v._v(" 设计原则")]),v._v(" "),a("ul",[a("li",[v._v("保持简单，第一法则")]),v._v(" "),a("li",[v._v("高可用")]),v._v(" "),a("li",[v._v("高并发")]),v._v(" "),a("li",[v._v("易扩展")]),v._v(" "),a("li",[v._v("弹性设计")]),v._v(" "),a("li",[v._v("封装微服务复杂度，业务开发友好")]),v._v(" "),a("li",[v._v("做一件事只提供一种方式")])]),v._v(" "),a("h2",{attrs:{id:"go服务实现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#go服务实现"}},[v._v("#")]),v._v(" Go服务实现")]),v._v(" "),a("p",[v._v("微服务重要组件")]),v._v(" "),a("ul",[a("li",[v._v("限流")]),v._v(" "),a("li",[v._v("自适应降载")]),v._v(" "),a("li",[v._v("自适应熔断")]),v._v(" "),a("li",[v._v("负载均衡")]),v._v(" "),a("li",[v._v("级联超时控制")]),v._v(" "),a("li",[v._v("缓存")]),v._v(" "),a("li",[v._v("可观测性")])]),v._v(" "),a("h2",{attrs:{id:"限流"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#限流"}},[v._v("#")]),v._v(" 限流")]),v._v(" "),a("h3",{attrs:{id:"进程内限流"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#进程内限流"}},[v._v("#")]),v._v(" 进程内限流")]),v._v(" "),a("ul",[a("li",[v._v("控制并发请求量")]),v._v(" "),a("li",[v._v("简单高效")]),v._v(" "),a("li",[v._v("可配置，有默认值")]),v._v(" "),a("li",[v._v("有效防止突发恶意流量")]),v._v(" "),a("li",[v._v("第一道防护（WAF等除外）")])]),v._v(" "),a("p",[a("img",{attrs:{src:"/images/image-20201104100022009.png",alt:"image-20201104100022009"}})]),v._v(" "),a("p",[v._v("如上图所示，我们可以在门口设置并发控制，让外面的人不会一股脑拥挤进来")]),v._v(" "),a("h3",{attrs:{id:"分布式限流"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#分布式限流"}},[v._v("#")]),v._v(" 分布式限流")]),v._v(" "),a("ul",[a("li",[v._v("基于redis / lua")]),v._v(" "),a("li",[v._v("令牌桶")]),v._v(" "),a("li",[v._v("漏铜")]),v._v(" "),a("li",[v._v("广泛适用，短信，推送等")])]),v._v(" "),a("p",[a("img",{attrs:{src:"/images/image-20201104100602605.png",alt:"image-20201104100602605"}})]),v._v(" "),a("h2",{attrs:{id:"自适应降载"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#自适应降载"}},[v._v("#")]),v._v(" 自适应降载")]),v._v(" "),a("p",[v._v("基于优先级进行分级降载保护")]),v._v(" "),a("ul",[a("li",[v._v("K8S的HPA 80%触发")]),v._v(" "),a("li",[v._v("CPU > 90% 开始拒绝低优先级请求")]),v._v(" "),a("li",[v._v("CPU > 95% 开始拒绝高优先级请求")]),v._v(" "),a("li",[v._v("http / rpc框架内建")]),v._v(" "),a("li",[v._v("基于滑动窗口，防止毛刺")]),v._v(" "),a("li",[v._v("有冷却时间，防止抖动")]),v._v(" "),a("li",[v._v("实践检验，配合K8S弹性伸缩")]),v._v(" "),a("li",[v._v("第二道防护")])]),v._v(" "),a("p",[a("img",{attrs:{src:"/images/image-20201104104250248.png",alt:"image-20201104104250248"}})]),v._v(" "),a("p",[v._v("高优先级和低优先级服务？")]),v._v(" "),a("ul",[a("li",[v._v("登录请求 是 高优先级请求")]),v._v(" "),a("li",[v._v("一些个人信息页这种，就是低优先级请求")])]),v._v(" "),a("h2",{attrs:{id:"自适应熔断"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#自适应熔断"}},[v._v("#")]),v._v(" 自适应熔断")]),v._v(" "),a("p",[v._v("路径级别的自适应熔断")]),v._v(" "),a("ul",[a("li",[v._v("自动触发，自动恢复")]),v._v(" "),a("li",[v._v("http /rpc 框架内建")]),v._v(" "),a("li",[v._v("Google SRE算法")]),v._v(" "),a("li",[v._v("放弃了Netfix Hystrix算法")]),v._v(" "),a("li",[v._v("基于滑动窗口（10秒 / 40窗口）")]),v._v(" "),a("li",[v._v("支持自定义触发条件")]),v._v(" "),a("li",[v._v("支持自定义fallback")]),v._v(" "),a("li",[v._v("第三道防护")])]),v._v(" "),a("p",[a("img",{attrs:{src:"/images/image-20201104105803487.png",alt:"image-20201104105803487"}})]),v._v(" "),a("h3",{attrs:{id:"netfix-hystrix算法-和-google-sre算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#netfix-hystrix算法-和-google-sre算法"}},[v._v("#")]),v._v(" Netfix Hystrix算法 和 Google SRE算法")]),v._v(" "),a("p",[v._v("Netfix Hystrix算法相比于 Google SRE算法，Hystrix算法没有那么灵敏，因为有三个状态")]),v._v(" "),a("ul",[a("li",[v._v("半开")]),v._v(" "),a("li",[v._v("闭")]),v._v(" "),a("li",[v._v("开")])]),v._v(" "),a("p",[v._v("而SRE算法是根据滑动窗口来的，能够很好的把握服务的状态，能够更加细粒度处理")]),v._v(" "),a("h2",{attrs:{id:"负载均衡"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#负载均衡"}},[v._v("#")]),v._v(" 负载均衡")]),v._v(" "),a("p",[v._v("负载均衡基于服务发现")]),v._v(" "),a("ul",[a("li",[v._v("服务提供方注册上报")]),v._v(" "),a("li",[v._v("服务调用方watch发现")]),v._v(" "),a("li",[v._v("进行服务调用")])]),v._v(" "),a("p",[a("img",{attrs:{src:"/images/image-20201104110133846.png",alt:"image-20201104110133846"}})]),v._v(" "),a("h3",{attrs:{id:"round-robin"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#round-robin"}},[v._v("#")]),v._v(" Round Robin")]),v._v(" "),a("p",[v._v("使用轮询的方式，来解决服务的负载均衡")]),v._v(" "),a("ul",[a("li",[v._v("简单")]),v._v(" "),a("li",[v._v("要求后端性能均等，也就是要求所有的机器性能一致的，不会出现性能的差别")]),v._v(" "),a("li",[v._v("响应时间变化较大时，容易出现负载不均衡")])]),v._v(" "),a("p",[a("img",{attrs:{src:"/images/image-20201104110258102.png",alt:"image-20201104110258102"}})]),v._v(" "),a("h3",{attrs:{id:"power-of-two-choices"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#power-of-two-choices"}},[v._v("#")]),v._v(" Power Of Two Choices")]),v._v(" "),a("p",[v._v("参考来自 Nginx & Envoy & Finagle & Linked的文章")]),v._v(" "),a("p",[v._v("https://www.nginx.com/blog/nginx-power-of-two-choices-load-balancing-algorithm/")]),v._v(" "),a("p",[v._v("https://linkerd.io/2016/03/16/beyond-round-robin-load-balancing-for-latency/index.html")]),v._v(" "),a("p",[v._v("Power Of Two Choices 主要用于当系统出现较高延迟的请求时")]),v._v(" "),a("ul",[a("li",[v._v("默认算法")]),v._v(" "),a("li",[v._v("当前请求数")]),v._v(" "),a("li",[v._v("处理时长，指数加权移动")]),v._v(" "),a("li",[v._v("e ^ (-x)")])]),v._v(" "),a("p",[a("img",{attrs:{src:"/images/image-20201104111213437.png",alt:"image-20201104111213437"}})]),v._v(" "),a("h2",{attrs:{id:"多重防护"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#多重防护"}},[v._v("#")]),v._v(" 多重防护")]),v._v(" "),a("p",[v._v("多重防护，保障高可用")]),v._v(" "),a("p",[a("img",{attrs:{src:"/images/image-20201104112647582.png",alt:"image-20201104112647582"}})]),v._v(" "),a("p",[v._v("这里主要分了三层的防护控制")]),v._v(" "),a("ul",[a("li",[v._v("第一层通过在网关处进行限流，拦截对应的请求，达到防护效果")]),v._v(" "),a("li",[v._v("第二层主要是自适应降载 和 K8S弹性伸缩，完成服务的可用性")]),v._v(" "),a("li",[v._v("第三方 在服务出现宕机时，触发熔断效果")])]),v._v(" "),a("p",[v._v("最后在一层调用一层，实现服务的可用")]),v._v(" "),a("h2",{attrs:{id:"级联超时控制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#级联超时控制"}},[v._v("#")]),v._v(" 级联超时控制")]),v._v(" "),a("h3",{attrs:{id:"进程内超时控制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#进程内超时控制"}},[v._v("#")]),v._v(" 进程内超时控制")]),v._v(" "),a("ul",[a("li",[v._v("Fail Fast，少做无用功")]),v._v(" "),a("li",[v._v("有默认值，业务开发无需关注")]),v._v(" "),a("li",[v._v("注意和客户端协同")])]),v._v(" "),a("p",[a("img",{attrs:{src:"/images/image-20201104113011565.png",alt:"image-20201104113011565"}})]),v._v(" "),a("p",[v._v("也就是说超时时间，是根据两个服务请求时间相加起来的，而不是每个服务都有一个时间")]),v._v(" "),a("h3",{attrs:{id:"服务间的超时控制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#服务间的超时控制"}},[v._v("#")]),v._v(" 服务间的超时控制")]),v._v(" "),a("ul",[a("li",[v._v("Fail Fast，少做无用功")]),v._v(" "),a("li",[v._v("通过context自动传递")]),v._v(" "),a("li",[v._v("忽略服务间调用网络损耗（一般几ms），降低复杂度")])]),v._v(" "),a("p",[a("img",{attrs:{src:"/images/image-20201104113239862.png",alt:"image-20201104113239862"}})]),v._v(" "),a("h2",{attrs:{id:"重试"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#重试"}},[v._v("#")]),v._v(" 重试？")]),v._v(" "),a("p",[v._v("go-zero 不支持超时重试！")]),v._v(" "),a("p",[v._v("重试机制注意事项")]),v._v(" "),a("ul",[a("li",[v._v("指数退避")]),v._v(" "),a("li",[v._v("流量quota")]),v._v(" "),a("li",[v._v("超时相关性")])]),v._v(" "),a("h2",{attrs:{id:"http请求自动解析校验"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#http请求自动解析校验"}},[v._v("#")]),v._v(" http请求自动解析校验")]),v._v(" "),a("p",[v._v("支持的特性")]),v._v(" "),a("ul",[a("li",[v._v("path，form，json")]),v._v(" "),a("li",[v._v("default，optional，options，range")])]),v._v(" "),a("p",[v._v("解析校验")]),v._v(" "),a("ul",[a("li",[v._v("httpx.Parse(...)")]),v._v(" "),a("li",[v._v("参数错误自动返回400")]),v._v(" "),a("li",[v._v("配合goctl使用，效果更佳")])]),v._v(" "),a("p",[a("img",{attrs:{src:"/images/image-20201104161742144.png",alt:"image-20201104161742144"}})]),v._v(" "),a("h2",{attrs:{id:"缓存"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#缓存"}},[v._v("#")]),v._v(" 缓存")]),v._v(" "),a("p",[v._v("缓存设计的三要点")]),v._v(" "),a("ul",[a("li",[v._v("缓存穿透，不存在的数据")]),v._v(" "),a("li",[v._v("缓存击穿，热点key过期")]),v._v(" "),a("li",[v._v("缓存雪崩，大量缓存同时过期")])]),v._v(" "),a("p",[a("img",{attrs:{src:"/images/image-20201104162246868.png",alt:"image-20201104162246868"}})]),v._v(" "),a("h3",{attrs:{id:"上述问题的解决思路"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#上述问题的解决思路"}},[v._v("#")]),v._v(" 上述问题的解决思路")]),v._v(" "),a("ul",[a("li",[a("p",[v._v("缓存穿透")]),v._v(" "),a("ul",[a("li",[v._v("即使查不到，也自动缓存，短过期时间，1分钟")])])]),v._v(" "),a("li",[a("p",[v._v("缓存击穿")]),v._v(" "),a("ul",[a("li",[v._v("确保一个进程同时只拿一次数据，并共享结果")])])]),v._v(" "),a("li",[a("p",[v._v("缓存雪崩")]),v._v(" "),a("ul",[a("li",[v._v("针对缓存过期时间，设置随机偏差，确保分散过期")])])]),v._v(" "),a("li",[a("p",[v._v("缓存基于非主键的查询")]),v._v(" "),a("ul",[a("li",[v._v("也就是有些查询，不是通过主键来进行缓存的，而是通过查询条件")]),v._v(" "),a("li",[v._v("可以说将查询条件，转换成了主键来进行缓存")]),v._v(" "),a("li",[v._v("获取复杂：查询 -> 主键 -> 缓存")]),v._v(" "),a("li",[v._v("过期复杂，顺序重要")])])]),v._v(" "),a("li",[a("p",[v._v("分布式缓存")]),v._v(" "),a("ul",[a("li",[v._v("多虚拟节点一致性hash，避免升降级后过多的cache miss")]),v._v(" "),a("li",[v._v("通过提出虚拟环的概念，避免因为单个缓存服务的添加和移除，导致大量的缓存记录失效")])])]),v._v(" "),a("li",[a("p",[v._v("很难全做对，是不是？")]),v._v(" "),a("ul",[a("li",[v._v("全部自动化，goctl自动生成CRUD + Cache代码，省力不出错")]),v._v(" "),a("li",[v._v("自带sql慢查询记录和缓存命中率统计")])])])]),v._v(" "),a("h2",{attrs:{id:"可观测性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#可观测性"}},[v._v("#")]),v._v(" 可观测性")]),v._v(" "),a("ul",[a("li",[v._v("链路跟踪")]),v._v(" "),a("li",[v._v("Logging日志")]),v._v(" "),a("li",[v._v("Metrics")]),v._v(" "),a("li",[v._v("监控报警")])]),v._v(" "),a("h3",{attrs:{id:"链路跟踪"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#链路跟踪"}},[v._v("#")]),v._v(" 链路跟踪")]),v._v(" "),a("ul",[a("li",[v._v("框架内建，context传递")]),v._v(" "),a("li",[v._v("Trace id，贯穿整个调用链")]),v._v(" "),a("li",[v._v("Span id，有层次和时序关系")]),v._v(" "),a("li",[v._v("记录起止时间")]),v._v(" "),a("li",[v._v("记录调用关系，client / server")])]),v._v(" "),a("p",[a("img",{attrs:{src:"/images/image-20201104164751086.png",alt:"image-20201104164751086"}})]),v._v(" "),a("h3",{attrs:{id:"logging日志"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#logging日志"}},[v._v("#")]),v._v(" Logging日志")]),v._v(" "),a("ul",[a("li",[v._v("自动rotate")]),v._v(" "),a("li",[v._v("多模式支持，console，file，volume")]),v._v(" "),a("li",[v._v("自动压缩")]),v._v(" "),a("li",[v._v("自动删除过期日志")])]),v._v(" "),a("p",[v._v("使用k8s会直接放到console中")]),v._v(" "),a("h3",{attrs:{id:"监控报警"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#监控报警"}},[v._v("#")]),v._v(" 监控报警")]),v._v(" "),a("ul",[a("li",[v._v("自动聚合汇报异常，比如 http code 5XX")]),v._v(" "),a("li",[v._v("自动控制频率并汇总异常")])]),v._v(" "),a("p",[a("img",{attrs:{src:"/images/image-20201104165254087.png",alt:"image-20201104165254087"}})]),v._v(" "),a("h3",{attrs:{id:"数据上报"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数据上报"}},[v._v("#")]),v._v(" 数据上报")]),v._v(" "),a("ul",[a("li",[v._v("上报到控制台服务")]),v._v(" "),a("li",[v._v("上报到promethenus（普罗米修斯监控平台）")])]),v._v(" "),a("p",[a("img",{attrs:{src:"/images/image-20201104165400359.png",alt:"image-20201104165400359"}})]),v._v(" "),a("h2",{attrs:{id:"其它"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#其它"}},[v._v("#")]),v._v(" 其它")]),v._v(" "),a("ul",[a("li",[v._v("基于JWT的自动鉴权")]),v._v(" "),a("li",[v._v("MapReduce\n"),a("ul",[a("li",[v._v("主要是用于进程内的，比如一个请求过来，但是这个请求可能会依赖后面很多个服务，但是很多个服务之间是没有先后顺序的，如果我们按流水线的方式处理，可能需要处理完第一个后，在处理第二个。。")]),v._v(" "),a("li",[v._v("如果不相关的服务，就可以使用MapReduce来进行并行的处理，来提高我们的响应速度")]),v._v(" "),a("li",[v._v("同时，如果我们某一个请求失败了，那么可以直接调用cancel，让其它的操作都失效，快速返回")])])]),v._v(" "),a("li",[v._v("Graceful shutdown")]),v._v(" "),a("li",[v._v("并发控制工具箱")]),v._v(" "),a("li",[v._v("资源控制工具箱，比如多个线程同时创建同一个数据库链接")]),v._v(" "),a("li",[v._v("分布式高可用延迟任务框架（后续开源）")]),v._v(" "),a("li",[v._v("极简Kafka Pub/Sub框架")]),v._v(" "),a("li",[v._v("Logstash 5倍性能的go-stash框架")]),v._v(" "),a("li",[v._v("不只是微服务框架，还有很多常见工具集")])]),v._v(" "),a("h2",{attrs:{id:"工具大于约定和文档"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#工具大于约定和文档"}},[v._v("#")]),v._v(" 工具大于约定和文档")]),v._v(" "),a("p",[v._v("goctl工具")]),v._v(" "),a("ul",[a("li",[v._v("极简API描述语法")]),v._v(" "),a("li",[v._v("极大简化前后端代码编写")]),v._v(" "),a("li",[v._v("减少沟通，避免出错")]),v._v(" "),a("li",[v._v("自动生成Golang后端Restful、RPC代码、IOS代码等，并可直接运行")]),v._v(" "),a("li",[v._v("自动生成CRUD + Cache代码")]),v._v(" "),a("li",[v._v("自动生成docker、K8S部署文件")])]),v._v(" "),a("p",[a("img",{attrs:{src:"/images/image-20201104224033260.png",alt:"image-20201104224033260"}})])])}),[],!1,null,null,null);_.default=t.exports}}]);