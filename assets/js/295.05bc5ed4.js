(window.webpackJsonp=window.webpackJsonp||[]).push([[295],{992:function(a,e,t){"use strict";t.r(e);var s=t(5),n=Object(s.a)({},(function(){var a=this,e=a.$createElement,t=a._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"cas底层原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#cas底层原理"}},[a._v("#")]),a._v(" CAS底层原理")]),a._v(" "),t("h2",{attrs:{id:"概念"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#概念"}},[a._v("#")]),a._v(" 概念")]),a._v(" "),t("p",[a._v("CAS的全称是Compare-And-Swap，它是CPU并发原语")]),a._v(" "),t("p",[a._v("它的功能是判断内存某个位置的值是否为预期值，如果是则更改为新的值，这个过程是原子的")]),a._v(" "),t("p",[a._v("CAS并发原语体现在Java语言中就是sun.misc.Unsafe类的各个方法。调用UnSafe类中的CAS方法，JVM会帮我们实现出CAS汇编指令，这是一种完全依赖于硬件的功能，通过它实现了原子操作，再次强调，由于CAS是一种系统原语，原语属于操作系统用于范畴，是由若干条指令组成，用于完成某个功能的一个过程，并且原语的执行必须是连续的，在执行过程中不允许被中断，也就是说CAS是一条CPU的原子指令，不会造成所谓的数据不一致的问题，也就是说CAS是线程安全的。")]),a._v(" "),t("h2",{attrs:{id:"代码使用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#代码使用"}},[a._v("#")]),a._v(" 代码使用")]),a._v(" "),t("p",[a._v("首先调用AtomicInteger创建了一个实例， 并初始化为5")]),a._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("        // 创建一个原子类\n        AtomicInteger atomicInteger = new AtomicInteger(5);\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br")])]),t("p",[a._v("然后调用CAS方法，企图更新成2019，这里有两个参数，一个是5，表示期望值，第二个就是我们要更新的值")]),a._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("atomicInteger.compareAndSet(5, 2019)\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br")])]),t("p",[a._v("然后再次使用了一个方法，同样将值改成1024")]),a._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("atomicInteger.compareAndSet(5, 1024)\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br")])]),t("p",[a._v("完整代码如下：")]),a._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v('/**\n * CASDemo\n *\n * 比较并交换：compareAndSet\n *\n * @author: 陌溪\n * @create: 2020-03-10-19:46\n */\npublic class CASDemo {\n    public static void main(String[] args) {\n        // 创建一个原子类\n        AtomicInteger atomicInteger = new AtomicInteger(5);\n\n        /**\n         * 一个是期望值，一个是更新值，但期望值和原来的值相同时，才能够更改\n         * 假设三秒前，我拿的是5，也就是expect为5，然后我需要更新成 2019\n         */\n        System.out.println(atomicInteger.compareAndSet(5, 2019) + "\\t current data: " + atomicInteger.get());\n\n        System.out.println(atomicInteger.compareAndSet(5, 1024) + "\\t current data: " + atomicInteger.get());\n    }\n}\n')])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br"),t("span",{staticClass:"line-number"},[a._v("3")]),t("br"),t("span",{staticClass:"line-number"},[a._v("4")]),t("br"),t("span",{staticClass:"line-number"},[a._v("5")]),t("br"),t("span",{staticClass:"line-number"},[a._v("6")]),t("br"),t("span",{staticClass:"line-number"},[a._v("7")]),t("br"),t("span",{staticClass:"line-number"},[a._v("8")]),t("br"),t("span",{staticClass:"line-number"},[a._v("9")]),t("br"),t("span",{staticClass:"line-number"},[a._v("10")]),t("br"),t("span",{staticClass:"line-number"},[a._v("11")]),t("br"),t("span",{staticClass:"line-number"},[a._v("12")]),t("br"),t("span",{staticClass:"line-number"},[a._v("13")]),t("br"),t("span",{staticClass:"line-number"},[a._v("14")]),t("br"),t("span",{staticClass:"line-number"},[a._v("15")]),t("br"),t("span",{staticClass:"line-number"},[a._v("16")]),t("br"),t("span",{staticClass:"line-number"},[a._v("17")]),t("br"),t("span",{staticClass:"line-number"},[a._v("18")]),t("br"),t("span",{staticClass:"line-number"},[a._v("19")]),t("br"),t("span",{staticClass:"line-number"},[a._v("20")]),t("br"),t("span",{staticClass:"line-number"},[a._v("21")]),t("br"),t("span",{staticClass:"line-number"},[a._v("22")]),t("br")])]),t("p",[a._v("上面代码的执行结果为")]),a._v(" "),t("p",[t("img",{attrs:{src:"/images/image-20200310201327734.png",alt:"image-20200310201327734"}})]),a._v(" "),t("p",[a._v("这是因为我们执行第一个的时候，期望值和原本值是满足的，因此修改成功，但是第二次后，主内存的值已经修改成了2019，不满足期望值，因此返回了false，本次写入失败")]),a._v(" "),t("p",[t("img",{attrs:{src:"/images/image-20200310201311367.png",alt:"image-20200310201311367"}})]),a._v(" "),t("p",[a._v("这个就类似于SVN或者Git的版本号，如果没有人更改过，就能够正常提交，否者需要先将代码pull下来，合并代码后，然后提交")]),a._v(" "),t("h2",{attrs:{id:"cas底层原理-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#cas底层原理-2"}},[a._v("#")]),a._v(" CAS底层原理")]),a._v(" "),t("p",[a._v("首先我们先看看 atomicInteger.getAndIncrement()方法的源码")]),a._v(" "),t("p",[t("img",{attrs:{src:"/images/image-20200310203030720.png",alt:"image-20200310203030720"}})]),a._v(" "),t("p",[a._v("从这里能够看到，底层又调用了一个unsafe类的getAndAddInt方法")]),a._v(" "),t("h3",{attrs:{id:"_1、unsafe类"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1、unsafe类"}},[a._v("#")]),a._v(" 1、unsafe类")]),a._v(" "),t("p",[t("img",{attrs:{src:"/images/image-20200310203350122.png",alt:"image-20200310203350122"}})]),a._v(" "),t("p",[a._v("Unsafe是CAS的核心类，由于Java方法无法直接访问底层系统，需要通过本地（Native）方法来访问，Unsafe相当于一个后门，基于该类可以直接操作特定的内存数据。Unsafe类存在sun.misc包中，其内部方法操作可以像C的指针一样直接操作内存，因为Java中的CAS操作的执行依赖于Unsafe类的方法。")]),a._v(" "),t("p",[t("code",[a._v("注意Unsafe类的所有方法都是native修饰的，也就是说unsafe类中的方法都直接调用操作系统底层资源执行相应的任务")])]),a._v(" "),t("p",[a._v("为什么Atomic修饰的包装类，能够保证原子性，依靠的就是底层的unsafe类")]),a._v(" "),t("h3",{attrs:{id:"_2、变量valueoffset"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2、变量valueoffset"}},[a._v("#")]),a._v(" 2、变量valueOffset")]),a._v(" "),t("p",[a._v("表示该变量值在内存中的偏移地址，因为Unsafe就是根据内存偏移地址获取数据的。")]),a._v(" "),t("p",[t("img",{attrs:{src:"/images/image-20200310203030720.png",alt:"image-20200310203030720"}})]),a._v(" "),t("p",[a._v("从这里我们能够看到，通过valueOffset，直接通过内存地址，获取到值，然后进行加1的操作")]),a._v(" "),t("h3",{attrs:{id:"_3、变量value用volatile修饰"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3、变量value用volatile修饰"}},[a._v("#")]),a._v(" 3、变量value用volatile修饰")]),a._v(" "),t("p",[a._v("保证了多线程之间的内存可见性")]),a._v(" "),t("p",[t("img",{attrs:{src:"/images/image-20200310210701761.png",alt:"image-20200310210701761"}})]),a._v(" "),t("p",[a._v("var5：就是我们从主内存中拷贝到工作内存中的值(每次都要从主内存拿到最新的值到自己的本地内存，然后执行compareAndSwapInt()在再和主内存的值进行比较。因为线程不可以直接越过高速缓存，直接操作主内存，所以执行上述方法需要比较一次，在执行加1操作)")]),a._v(" "),t("p",[a._v("那么操作的时候，需要比较工作内存中的值，和主内存中的值进行比较")]),a._v(" "),t("p",[a._v("假设执行 compareAndSwapInt返回false，那么就一直执行 while方法，直到期望的值和真实值一样")]),a._v(" "),t("ul",[t("li",[a._v("val1：AtomicInteger对象本身")]),a._v(" "),t("li",[a._v("var2：该对象值得引用地址")]),a._v(" "),t("li",[a._v("var4：需要变动的数量")]),a._v(" "),t("li",[a._v("var5：用var1和var2找到的内存中的真实值\n"),t("ul",[t("li",[a._v("用该对象当前的值与var5比较")]),a._v(" "),t("li",[a._v("如果相同，更新var5 + var4 并返回true")]),a._v(" "),t("li",[a._v("如果不同，继续取值然后再比较，直到更新完成")])])])]),a._v(" "),t("p",[a._v("这里没有用synchronized，而用CAS，这样提高了并发性，也能够实现一致性，是因为每个线程进来后，进入的do while循环，然后不断的获取内存中的值，判断是否为最新，然后在进行更新操作。")]),a._v(" "),t("p",[a._v("假设线程A和线程B同时执行getAndInt操作（分别跑在不同的CPU上）")]),a._v(" "),t("ol",[t("li",[a._v("AtomicInteger里面的value原始值为3，即主内存中AtomicInteger的 value 为3，根据JMM模型，线程A和线程B各自持有一份价值为3的副本，分别存储在各自的工作内存")]),a._v(" "),t("li",[a._v("线程A通过getIntVolatile(var1 , var2) 拿到value值3，这是线程A被挂起（该线程失去CPU执行权）")]),a._v(" "),t("li",[a._v("线程B也通过getIntVolatile(var1, var2)方法获取到value值也是3，此时刚好线程B没有被挂起，并执行了compareAndSwapInt方法，比较内存的值也是3，成功修改内存值为4，线程B打完收工，一切OK")]),a._v(" "),t("li",[a._v("这是线程A恢复，执行CAS方法，比较发现自己手里的数字3和主内存中的数字4不一致，说明该值已经被其它线程抢先一步修改过了，那么A线程本次修改失败，只能够重新读取后在来一遍了，也就是在执行do while")]),a._v(" "),t("li",[a._v("线程A重新获取value值，因为变量value被volatile修饰，所以其它线程对它的修改，线程A总能够看到，线程A继续执行compareAndSwapInt进行比较替换，直到成功。")])]),a._v(" "),t("p",[a._v("Unsafe类 + CAS思想： 也就是自旋，自我旋转")]),a._v(" "),t("h2",{attrs:{id:"底层汇编"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#底层汇编"}},[a._v("#")]),a._v(" 底层汇编")]),a._v(" "),t("p",[a._v("Unsafe类中的compareAndSwapInt是一个本地方法，该方法的实现位于unsafe.cpp中")]),a._v(" "),t("ul",[t("li",[a._v("先想办法拿到变量value在内存中的地址")]),a._v(" "),t("li",[a._v("通过Atomic::cmpxchg实现比较替换，其中参数X是即将更新的值，参数e是原内存的值")])]),a._v(" "),t("h2",{attrs:{id:"cas缺点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#cas缺点"}},[a._v("#")]),a._v(" CAS缺点")]),a._v(" "),t("p",[a._v("CAS不加锁，保证一次性，但是需要多次比较")]),a._v(" "),t("ul",[t("li",[a._v("循环时间长，开销大（因为执行的是do while，如果比较不成功一直在循环，最差的情况，就是某个线程一直取到的值和预期值都不一样，这样就会无限循环）")]),a._v(" "),t("li",[a._v("只能保证一个共享变量的原子操作\n"),t("ul",[t("li",[a._v("当对一个共享变量执行操作时，我们可以通过循环CAS的方式来保证原子操作")]),a._v(" "),t("li",[a._v("但是对于多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候只能用锁来保证原子性")])])]),a._v(" "),t("li",[a._v("引出来ABA问题？")])]),a._v(" "),t("h2",{attrs:{id:"aba问题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#aba问题"}},[a._v("#")]),a._v(" ABA问题")]),a._v(" "),t("p",[a._v("。。。。。。。。。")]),a._v(" "),t("h2",{attrs:{id:"总结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[a._v("#")]),a._v(" 总结")]),a._v(" "),t("h3",{attrs:{id:"cas"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#cas"}},[a._v("#")]),a._v(" CAS")]),a._v(" "),t("p",[a._v("CAS是compareAndSwap，比较当前工作内存中的值和主物理内存中的值，如果相同则执行规定操作，否者继续比较直到主内存和工作内存的值一致为止")]),a._v(" "),t("h3",{attrs:{id:"cas应用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#cas应用"}},[a._v("#")]),a._v(" CAS应用")]),a._v(" "),t("p",[a._v("CAS有3个操作数，内存值V，旧的预期值A，要修改的更新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否者什么都不做")])])}),[],!1,null,null,null);e.default=n.exports}}]);