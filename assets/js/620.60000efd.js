(window.webpackJsonp=window.webpackJsonp||[]).push([[620],{1317:function(n,e,t){"use strict";t.r(e);var a=t(5),i=Object(a.a)({},(function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("h1",{attrs:{id:"java并发编程基础"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#java并发编程基础"}},[n._v("#")]),n._v(" Java并发编程基础")]),n._v(" "),t("h2",{attrs:{id:"线程简介"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#线程简介"}},[n._v("#")]),n._v(" 线程简介")]),n._v(" "),t("h3",{attrs:{id:"什么是线程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是线程"}},[n._v("#")]),n._v(" 什么是线程")]),n._v(" "),t("p",[n._v("现代操作系统在运行一个程序时，会为其创建一个进程。例如，启动一个Java程序，操作系统就会创建一个Java进程。现代操作系统调度的最小单元是线程，也叫轻量级进程（LightWeight Process），在一个进程里可以创建多个线程，这些线程都拥有各自的计数器、堆栈和局部变量等属性，并且能够访问共享的内存变量。处理器在这些线程上高速切换，让使用者感觉到这些线程在同时执行。")]),n._v(" "),t("p",[n._v("一个Java程序从main()方法开始执行，然后按照既定的代码逻辑执行，看似没有其他线程参与，但实际上Java程序天生就是多线程程序，因为执行main()方法的是一个名称为main的线程。下面使用JMX来查看一个普通的Java程序包含哪些线程")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v('public class MultiThread {\n    \n    public static void main(String[] args) {\n        // 获取Java线程管理MXBean\n        ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();\n        // 不需要获取同步的monitor和synchronizer信息，仅获取线程和线程堆栈信息\n        ThreadInfo[] threadInfos = threadMXBean.dumpAllThreads(false, false);\n        // 遍历线程信息，仅打印线程ID和线程名称信息\n        for (ThreadInfo threadInfo : threadInfos) {\n            System.out.println("["+threadInfo.getThreadId()+"] "+threadInfo.getThreadName());\n        }\n    }\n}\n')])])]),t("p",[n._v("输出如下所示（输出内容可能不同）。")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("[4] Signal Dispatcher　 // 分发处理发送给JVM信号的线程\n[3] Finalizer　　　　 // 调用对象finalize方法的线程\n[2] Reference Handler // 清除Reference的线程\n[1] main　 　　　　 // main线程，用户程序入口\n")])])]),t("h3",{attrs:{id:"为什么要使用多线程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#为什么要使用多线程"}},[n._v("#")]),n._v(" 为什么要使用多线程")]),n._v(" "),t("p",[n._v("（1）更多的处理器核心")]),n._v(" "),t("p",[n._v("线程是大多数操作系统调度的基本单元，一个程序作为一个进程来运行，程序运行过程中能够创建多个线程，而一个线程在一个时刻只能运行在一个处理器核心上。试想一下，一个单线程程序在运行时只能使用一个处理器核心，那么再多的处理器核心加入也无法显著提升该程序的执行效率。相反，如果该程序使用多线程技术，将计算逻辑分配到多个处理器核心上，就会显著减少程序的处理时间，并且随着更多处理器核心的加入而变得更有效率。")]),n._v(" "),t("p",[n._v("（2）更快的响应时间")]),n._v(" "),t("p",[n._v("（3）更好的编程模型")]),n._v(" "),t("h3",{attrs:{id:"线程优先级"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#线程优先级"}},[n._v("#")]),n._v(" 线程优先级")]),n._v(" "),t("p",[n._v("在Java线程中，通过一个整型成员变量priority来控制优先级，优先级的范围从1~10，在线程构建的时候可以通过setPriority(int)方法来修改优先级，默认优先级是5，优先级高的线程分配时间片的数量要多于优先级低的线程。设置线程优先级时，针对频繁阻塞（休眠或者I/O操作）的线程需要设置较高优先级，而偏重计算（需要较多CPU时间或者偏运算）的线程则设置较低的优先级，确保处理器不会被独占。在不同的JVM以及操作系统上，线程规划会存在差异，有些操作系统甚至会忽略对线程优先级的设定.")]),n._v(" "),t("h3",{attrs:{id:"线程的状态"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#线程的状态"}},[n._v("#")]),n._v(" 线程的状态")]),n._v(" "),t("p",[n._v("Java线程在运行的生命周期中可能处于表4-1所示的6种不同的状态，在给定的一个时刻，线程只能处于其中的一个状态。")]),n._v(" "),t("p",[n._v("状态名称")]),n._v(" "),t("p",[n._v("说明")]),n._v(" "),t("p",[n._v("NEW")]),n._v(" "),t("p",[n._v("初始状态,线程被构建,但是还没有被调用start()方法")]),n._v(" "),t("p",[n._v("RUNNABLE")]),n._v(" "),t("p",[n._v('运行状态,Java线程将操作系统中的就绪和运行两种状态笼统乘坐"运行中"')]),n._v(" "),t("p",[n._v("BLOCKED")]),n._v(" "),t("p",[n._v("阻塞状态,表示线程阻塞于锁")]),n._v(" "),t("p",[n._v("WAITING")]),n._v(" "),t("p",[n._v("等待状态,表示线程进入等待状态,进入该状态表示当前线程需要等待其他线程做出一些特定动作(通知或中断)")]),n._v(" "),t("p",[n._v("TIME_WAITING")]),n._v(" "),t("p",[n._v("超时等待状态,改状态不同于WAITING,它是可以在指定的时间自行返回的")]),n._v(" "),t("p",[n._v("TERMINATED")]),n._v(" "),t("p",[n._v("终止状态,表示当前线程已经被执行完毕")]),n._v(" "),t("p",[n._v("线程创建之后，调用start()方法开始运行。当线程执行wait()方法之后，线程进入等待状态。进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态，而超时等待状态相当于在等待状态的基础上增加了超时限制，也就是超时时间到达时将会返回到运行状态。当线程调用同步方法时，在没有获取到锁的情况下，线程将会进入到阻塞状态。线程在执行Runnable的run()方法之后将会进入到终止状态。")]),n._v(" "),t("h3",{attrs:{id:"daemon线程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#daemon线程"}},[n._v("#")]),n._v(" Daemon线程")]),n._v(" "),t("p",[n._v("Daemon线程是一种支持型线程，因为它主要被用作程序中后台调度以及支持性工作。这意味着，当一个Java虚拟机中不存在非Daemon线程的时候，Java虚拟机将会退出。可以通过调用Thread.setDaemon(true)将线程设置为Daemon线程。")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v('public class Daemon {\n    \n    public static void main(String[] args) {\n        Thread thread = new Thread(new DaemonRunner(),"DaemonRunner");\n        thread.setDaemon(true);\n        thread.start();\n    }\n    \n    static class DaemonRunner implements Runnable{\n        @Override\n        public void run() {\n            try{\n                SleepUtils.second(10);\n            }finally{\n                System.out.println("DaemonThread finally run.");\n            }\n        }\n    }\n}   \n')])])]),t("p",[n._v("运行Daemon程序，可以看到在终端或者命令提示符上没有任何输出。main线程（非Daemon线程）在启动了线程DaemonRunner之后随着main方法执行完毕而终止，而此时Java虚拟机中已经没有非Daemon线程，虚拟机需要退出。Java虚拟机中的所有Daemon线程都需要立即终止，因此DaemonRunner立即终止，但是DaemonRunner中的finally块并没有执行。")]),n._v(" "),t("p",[t("strong",[n._v("注意")]),n._v("　在构建Daemon线程时，不能依靠finally块中的内容来确保执行关闭或清理资源的逻辑。")]),n._v(" "),t("h2",{attrs:{id:"启动和终止线程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#启动和终止线程"}},[n._v("#")]),n._v(" 启动和终止线程")]),n._v(" "),t("h3",{attrs:{id:"构造线程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#构造线程"}},[n._v("#")]),n._v(" 构造线程")]),n._v(" "),t("h3",{attrs:{id:"启动线程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#启动线程"}},[n._v("#")]),n._v(" 启动线程")]),n._v(" "),t("p",[n._v("线程对象在初始化完成之后，调用start()方法就可以启动这个线程。线程start()方法的含义是：当前线程（即parent线程）同步告知Java虚拟机，只要线程规划器空闲，应立即启动调用start()方法的线程。")]),n._v(" "),t("h3",{attrs:{id:"理解中断"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#理解中断"}},[n._v("#")]),n._v(" 理解中断")]),n._v(" "),t("p",[n._v("中断可以理解为线程的一个标识位属性，它表示一个运行中的线程是否被其他线程进行了中断操作。中断好比其他线程对该线程打了个招呼，其他线程通过调用该线程的interrupt()方法对其进行中断操作。")]),n._v(" "),t("p",[n._v("线程通过检查自身是否被中断来进行响应，线程通过方法isInterrupted()来进行判断是否被中断，也可以调用静态方法Thread.interrupted()对当前线程的中断标识位进行复位。如果该线程已经处于终结状态，即使该线程被中断过，在调用该线程对象的isInterrupted()时依旧会返回false。")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v('public class Interrupted {\n    \n    public static void main(String[] args) throws InterruptedException {\n        //sleepThread不停的尝试睡眠\n        Thread sleepThread= new Thread(new SleepRunner(),"SleepRunner");\n        sleepThread.setDaemon(true);\n         // busyThread不停的运行\n        Thread busyThread = new Thread(new BusyRunner(),"BusyRunner");\n        busyThread.setDaemon(true);\n        sleepThread.start();\n        busyThread.start();\n      // 休眠5秒，让sleepThread和busyThread充分运行\n        TimeUnit.SECONDS.sleep(5);\n        sleepThread.interrupt();\n        busyThread.interrupt();\n        System.out.println("SleepThread interrupted is "+sleepThread.isInterrupted());\n        System.out.println("BusyThread interrupted is "+busyThread.isInterrupted());\n      // 防止sleepThread和busyThread立刻退出\n        TimeUnit.SECONDS.sleep(2);\n    }\n    \n    static class SleepRunner implements Runnable{\n        @Override\n        public void run() {\n            while(true){\n                SleepUtils.second(10);\n            }\n        }\n    }\n    \n    static class BusyRunner implements Runnable{\n\n        @Override\n        public void run() {\n            while(true){}\n        }\n    }\n}\n')])])]),t("h2",{attrs:{id:"安全地终止线程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#安全地终止线程"}},[n._v("#")]),n._v(" 安全地终止线程")]),n._v(" "),t("p",[n._v("创建了一个线程CountThread，它不断地进行变量累加，而主线程尝试对其进行中断操作和停止操作。")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v('public class Shutdown {\n    \n    public static void main(String[] args) throws InterruptedException {\n        Runner one = new Runner();\n        Thread countThread = new Thread(one,"CountThread");\n        countThread.start();\n        TimeUnit.SECONDS.sleep(1);\n        countThread.interrupt();\n        Runner two = new Runner();\n        countThread = new Thread(two,"CountThread");\n        countThread.start();\n        TimeUnit.SECONDS.sleep(1);\n        two.cancel();\n    }\n    \n    private static class Runner implements Runnable{\n        private long i;\n        private volatile boolean on = true;\n        @Override\n        public void run() {\n            while(on && !Thread.currentThread().isInterrupted()){\n                i++;\n            }\n            System.out.println("Count i = "+i);\n        }\n        public void cancel(){\n            on = false;\n        }\n    }\n}\n')])])]),t("h2",{attrs:{id:"线程间通信"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#线程间通信"}},[n._v("#")]),n._v(" 线程间通信")]),n._v(" "),t("h3",{attrs:{id:"volatile和synchronized关键字"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#volatile和synchronized关键字"}},[n._v("#")]),n._v(" volatile和synchronized关键字")]),n._v(" "),t("p",[n._v("Java支持多个线程同时访问一个对象或者对象的成员变量，由于每个线程可以拥有这个变量的拷贝（虽然对象以及成员变量分配的内存是在共享内存中的，但是每个执行的线程还是可以拥有一份拷贝，这样做的目的是加速程序的执行，这是现代多核处理器的一个显著特性），所以程序在执行过程中，一个线程看到的变量并不一定是最新的。")]),n._v(" "),t("p",[n._v("关键字volatile可以用来修饰字段（成员变量），就是告知程序任何对该变量的访问均需要从共享内存中获取，而对它的改变必须同步刷新回共享内存，它能保证所有线程对变量访问的可见性。")]),n._v(" "),t("p",[n._v("举个例子，定义一个表示程序是否运行的成员变量boolean on=true，那么另一个线程可能对它执行关闭动作（on=false），这里涉及多个线程对变量的访问，因此需要将其定义成为volatile boolean on＝true，这样其他线程对它进行改变时，可以让所有线程感知到变化，因为所有对on变量的访问和修改都需要以共享内存为准。但是，过多地使用volatile是不必要的，因为它会降低程序执行的效率。")]),n._v(" "),t("p",[n._v("关键字synchronized可以修饰方法或者以同步块的形式来进行使用，它主要确保多个线程在同一个时刻，只能有一个线程处于方法或者同步块中，它保证了线程对变量访问的可见性和排他性。")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("public class Synchronized {\n    \n    public static void main(String[] args) {\n        //对synchronized Class对象进行加锁\n        synchronized (Synchronized.class) {\n        }\n        //静态同步方法,对synchronized Class对象进行加锁\n        m();\n    }\n    \n    public static synchronized void m(){\n        \n    }\n}   \n")])])]),t("h3",{attrs:{id:"等待-通知机制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#等待-通知机制"}},[n._v("#")]),n._v(" 等待/通知机制")]),n._v(" "),t("p",[n._v("一个线程修改了一个对象的值，而另一个线程感知到了变化，然后进行相应的操作，整个过程开始于一个线程，而最终执行又是另一个线程。前者是生产者，后者就是消费者，这种模式隔离了“做什么”（what）和“怎么做”（How），在功能层面上实现了解耦，体系结构上具备了良好的伸缩性，但是在Java语言中如何实现类似的功能呢？")]),n._v(" "),t("p",[n._v("简单的办法是让消费者线程不断地循环检查变量是否符合预期，如下面代码所示，在while循环中设置不满足的条件，如果条件满足则退出while循环，从而完成消费者的工作。")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("while(value != desire){\n    Thread.sleep(10000);\n}\ndoSomething();\n")])])]),t("p",[n._v("上面这段伪代码在条件不满足时就睡眠一段时间，这样做的目的是防止过快的“无效”尝试，这种方式看似能够解实现所需的功能，但是却存在如下问题。")]),n._v(" "),t("p",[n._v("1）难以确保及时性。在睡眠时，基本不消耗处理器资源，但是如果睡得过久，就不能及时发现条件已经变化，也就是及时性难以保证。"),t("br"),n._v("\n2）难以降低开销。如果降低睡眠的时间，比如休眠1毫秒，这样消费者能更加迅速地发现条件变化，但是却可能消耗更多的处理器资源，造成了无端的浪费。")]),n._v(" "),t("p",[n._v("等待/通知机制，是指一个线程A调用了对象O的wait()方法进入等待状态，而另一个线程B调用了对象O的notify()或者notifyAll()方法，线程A收到通知后从对象O的wait()方法返回，进而执行后续操作。上述两个线程通过对象O来完成交互，而对象上的wait()和notify/notifyAll()的关系就如同开关信号一样，用来完成等待方和通知方之间的交互工作。")]),n._v(" "),t("p",[n._v("在代码清单4-11所示的例子中，创建了两个线程——WaitThread和NotifyThread，前者检查flag值是否为false，如果符合要求，进行后续操作，否则在lock上等待，后者在睡眠了一段时间后对lock进行通知，示例如下所示。")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v('public class WaitNotify {\n    static boolean flag = true;\n    static Object lock = new Object();\n    \n    public static void main(String[] args) throws InterruptedException {\n        Thread waitThread = new Thread(new Wait(),"WaitThread");\n        waitThread.start();\n        TimeUnit.SECONDS.sleep(1);\n        Thread notifyThread = new Thread(new Notify(),"NotifyThread");\n        notifyThread.start();\n    }\n    \n    static class Wait implements Runnable{\n        @Override\n        public void run() {\n            synchronized (lock) {\n                //当条件不满足时,继续wait,同时释放了lock的锁\n                while(flag){\n                    try {\n                        System.out.println(Thread.currentThread()+" flag is true. wa@ "+new SimpleDateFormat("HH:mm:ss").format(new Date()));\n                        lock.wait();\n                    } catch (Exception e) {\n                    }\n                }\n                //条件满足时,完成工作\n                System.out.println(Thread.currentThread()+" flag is false . running @ "+new SimpleDateFormat("HH:mm:ss").format(new Date()));\n            }\n        }\n    }\n    static class Notify implements Runnable{\n        @Override\n        public void run() {\n            synchronized (lock) {\n                //获取Lock锁,然后进行通知,通知时不会释放lock的锁\n                //直到当前线程释放了lock后,waitThread才能从wait方法中返回\n                System.out.println(Thread.currentThread()+" hold lock.notify @ "+new SimpleDateFormat("HH:mm:ss").format(new Date()));\n                lock.notifyAll();\n                flag = false;\n                SleepUtils.second(5);\n            }\n            \n            synchronized (lock) {\n                System.out.println(Thread.currentThread()+" hold lock again. sleep @ "+new SimpleDateFormat("HH:mm:ss").format(new Date()));\n                SleepUtils.second(5);\n            }\n        }\n        \n    }\n}\n\nThread[WaitThread,5,main] flag is true. wa@ 10:04:53\nThread[NotifyThread,5,main] hold lock.notify @ 10:04:54\nThread[NotifyThread,5,main] hold lock again. sleep @ 10:04:59\nThread[WaitThread,5,main] flag is false . running @ 10:05:04\n')])])]),t("p",[n._v("上述第3行和第4行输出的顺序可能会互换，而上述例子主要说明了调用wait()、notify()以及notifyAll()时需要注意的细节，如下。"),t("br"),n._v("\n1）使用wait()、notify()和notifyAll()时需要先对调用对象加锁。"),t("br"),n._v("\n2）调用wait()方法后，线程状态由RUNNING变为WAITING，并将当前线程放置到对象的等待队列。"),t("br"),n._v("\n3）notify()或notifyAll()方法调用后，等待线程依旧不会从wait()返回，需要调用notify()或notifAll()的线程释放锁之后，等待线程才有机会从wait()返回。"),t("br"),n._v("\n4）notify()方法将等待队列中的一个等待线程从等待队列中移到同步队列中，而notifyAll()方法则是将等待队列中所有的线程全部移到同步队列，被移动的线程状态由WAITING变为BLOCKED。"),t("br"),n._v("\n5）从wait()方法返回的前提是获得了调用对象的锁。")]),n._v(" "),t("p",[n._v("WaitThread首先获取了对象的锁，然后调用对象的wait()方法，从而放弃了锁并进入了对象的等待队WaitQueue中，进入等待状态。由于WaitThread释放了对象的锁，NotifyThread随后获取了对象的锁，并调用对象的notify()方法，将WaitThread从WaitQueue移到SynchronizedQueue中，此时WaitThread的状态变为阻塞状态。NotifyThread释放了锁之后，WaitThread再次获取到锁并从wait()方法返回继续执行。")]),n._v(" "),t("h3",{attrs:{id:"等待-通知的经典范式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#等待-通知的经典范式"}},[n._v("#")]),n._v(" 等待/通知的经典范式")]),n._v(" "),t("p",[n._v("从4.3.2节中的WaitNotify示例中可以提炼出等待/通知的经典范式，该范式分为两部分，分别针对等待方（消费者）和通知方（生产者）。"),t("br"),n._v("\n等待方遵循如下原则。"),t("br"),n._v("\n1）获取对象的锁。"),t("br"),n._v("\n2）如果条件不满足，那么调用对象的wait()方法，被通知后仍要检查条件。"),t("br"),n._v("\n3）条件满足则执行对应的逻辑。"),t("br"),n._v("\n对应的伪代码如下。")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("synchronized(对象) {\n    while(条件不满足) {\n        对象.wait();  \n    }\n    对应的处理逻辑\n}\n")])])]),t("p",[n._v("通知方遵循如下原则。"),t("br"),n._v("\n1）获得对象的锁。"),t("br"),n._v("\n2）改变条件。"),t("br"),n._v("\n3）通知所有等待在对象上的线程。"),t("br"),n._v("\n对应的伪代码如下。")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("synchronized(对象) {\n    改变条件\n    对象.notifyAll();\n}\n")])])]),t("h3",{attrs:{id:"管道输入-输出流"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#管道输入-输出流"}},[n._v("#")]),n._v(" 管道输入/输出流")]),n._v(" "),t("p",[n._v("管道输入/输出流和普通的文件输入/输出流或者网络输入/输出流不同之处在于，它主要用于线程之间的数据传输，而传输的媒介为内存。"),t("br"),n._v("\n管道输入/输出流主要包括了如下4种具体实现：PipedOutputStream、PipedInputStream、PipedReader和PipedWriter，前两种面向字节，而后两种面向字符。")]),n._v(" "),t("p",[n._v("在代码清单4-12所示的例子中，创建了printThread，它用来接受main线程的输入，任何main线程的输入均通过PipedWriter写入，而printThread在另一端通过PipedReader将内容读出并打印。")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v('public class Piped {\n    public static void main(String[] args) throws Exception {\n        PipedWriter out = new PipedWriter();\n        PipedReader in = new PipedReader();\n        // 将输出流和输入流进行连接，否则在使用时会抛出IOException\n        out.connect(in);\n        Thread printThread = new Thread(new Print(in), "PrintThread");\n        printThread.start();\n        int receive = 0;\n        try {\n            while((receive = System.in.read()) != -1){\n                out.write(receive);\n            }\n        } finally {\n            out.close();\n        }\n    }\n    \n    static class Print implements Runnable{\n        private PipedReader in;\n        public Print(PipedReader in) {\n            this.in = in;\n        }\n        @Override\n        public void run() {\n            int receive =0;\n            try{\n                while((receive = in.read()) != -1){\n                    System.out.print((char)receive);\n                }\n            }catch(Exception e){\n                \n            }\n        }\n        \n    }\n}\n')])])]),t("p",[n._v("对于Piped类型的流，必须先要进行绑定，也就是调用connect()方法，如果没有将输入/输出流绑定起来，对于该流的访问将会抛出异常。")]),n._v(" "),t("h3",{attrs:{id:"threadlocal的使用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#threadlocal的使用"}},[n._v("#")]),n._v(" ThreadLocal的使用")]),n._v(" "),t("p",[n._v("ThreadLocal，即线程变量，是一个以ThreadLocal对象为键、任意对象为值的存储结构。这个结构被附带在线程上，也就是说一个线程可以根据一个ThreadLocal对象查询到绑定在这个线程上的一个值。")]),n._v(" "),t("p",[n._v("可以通过set(T)方法来设置一个值，在当前线程下再通过get()方法获取到原先设置的值。"),t("br"),n._v("\n在代码清单4-15所示的例子中，构建了一个常用的Profiler类，它具有begin()和end()两个方法，而end()方法返回从begin()方法调用开始到end()方法被调用时的时间差，单位是毫秒。")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v('public class Profiler {\n    private static final ThreadLocal<Long> TIME_THREADLOCAL =new ThreadLocal<>();\n    protected Long initialValue(){\n        return System.currentTimeMillis();\n    }\n    \n    public static final void begin(){\n        TIME_THREADLOCAL.set(System.currentTimeMillis());\n    }\n    public static final long end(){\n        return System.currentTimeMillis() - TIME_THREADLOCAL.get();\n    }\n    public static void main(String[] args) throws InterruptedException {\n        Profiler.begin();\n        TimeUnit.SECONDS.sleep(1);\n        System.out.println("Cost: "+Profiler.end()+" mills");\n    }\n}\n')])])]),t("p",[n._v("Profiler可以被复用在方法调用耗时统计的功能上，在方法的入口前执行begin()方法，在方法调用后执行end()方法，好处是两个方法的调用不用在一个方法或者类中，比如在AOP（面向方面编程）中，可以在方法调用前的切入点执行begin()方法，而在方法调用后的切入点执行end()方法，这样依旧可以获得方法的执行耗时。")]),n._v(" "),t("h2",{attrs:{id:"线程应用实例"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#线程应用实例"}},[n._v("#")]),n._v(" 线程应用实例")]),n._v(" "),t("h3",{attrs:{id:"等待超时模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#等待超时模式"}},[n._v("#")]),n._v(" 等待超时模式")]),n._v(" "),t("p",[n._v("开发人员经常会遇到这样的方法调用场景：调用一个方法时等待一段时间（一般来说是给定一个时间段），如果该方法能够在给定的时间段之内得到结果，那么将结果立刻返回，反之，超时返回默认结果。")]),n._v(" "),t("p",[n._v("前面的章节介绍了等待/通知的经典范式，即加锁、条件循环和处理逻辑3个步骤，而这种范式无法做到超时等待。而超时等待的加入，只需要对经典范式做出非常小的改动，改动内容如下所示。"),t("br"),n._v("\n假设超时时间段是T，那么可以推断出在当前时间now+T之后就会超时。")]),n._v(" "),t("p",[n._v("定义如下变量。"),t("br"),n._v("\n·等待持续时间：REMAINING=T。"),t("br"),n._v("\n·超时时间：FUTURE=now+T。"),t("br"),n._v("\n这时仅需要wait(REMAINING)即可，在wait(REMAINING)返回之后会将执行："),t("br"),n._v("\nREMAINING=FUTURE–now。如果REMAINING小于等于0，表示已经超时，直接退出，否则将继续执行wait(REMAINING)。")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("public synchronized Object get(long mills)throws InterruptedException{\n    long future = System.currentTimeMillis()+mills;\n    long remaining = mills;\n    //当超时大于0并且result返回值不满足要求\n    while((result == null) && remaining >0){\n        wait(remaining);\n        remaining = future - System.currentTimeMills();\n    }\n    return result;\n}\n")])])]),t("p",[n._v("可以看出，等待超时模式就是在等待/通知范式基础上增加了超时控制，这使得该模式相比原有范式更具有灵活性，因为即使方法执行时间过长，也不会“永久”阻塞调用者，而是会按照调用者的要求“按时”返回。")]),n._v(" "),t("h3",{attrs:{id:"一个简单的数据库连接池示例"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#一个简单的数据库连接池示例"}},[n._v("#")]),n._v(" 一个简单的数据库连接池示例")]),n._v(" "),t("p",[n._v("我们使用等待超时模式来构造一个简单的数据库连接池，在示例中模拟从连接池中获取、使用和释放连接的过程，而客户端获取连接的过程被设定为等待超时的模式，也就是在1000毫秒内如果无法获取到可用连接，将会返回给客户端一个null。设定连接池的大小为10个，然后通过调节客户端的线程数来模拟无法获取连接的场景。")]),n._v(" "),t("p",[n._v("首先看一下连接池的定义。它通过构造函数初始化连接的最大上限，通过一个双向队列来维护连接，调用方需要先调用fetchConnection(long)方法来指定在多少毫秒内超时获取连接，当连接使用完成后，需要调用releaseConnection(Connection)方法将连接放回线程池，示例如代码清单4-16所示。")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("public class ConnectionPool {\n    private LinkedList<Connection> pool = new LinkedList<>();\n    public ConnectionPool(int initialSize){\n        if(initialSize>0){\n            for(int i =0;i<initialSize;i++){\n                pool.addLast(ConnectionDriver.createConnection());\n            }\n        }\n    }\n    public void releaseConnection(Connection connection){\n        if(connection !=null){\n            synchronized (pool) {\n                // 连接释放后需要进行通知，这样其他消费者能够感知到连接池中已经归还了一个连接\n                pool.addLast(connection);\n                pool.notifyAll();\n            }\n        }\n    }\n    // 在mills内无法获取到连接，将会返回null\n    public Connection fetchConnection(long mills) throws Exception{\n        synchronized (pool) {\n            // 完全超时\n            if(mills <=0){\n                while(pool.isEmpty()){\n                    pool.wait();\n                }\n                return pool.removeFirst();\n            }else{\n                long future = System.currentTimeMillis()+mills;\n                long remaining = mills;\n                while(pool.isEmpty() && remaining>0){\n                    pool.wait(remaining);\n                    remaining = future - System.currentTimeMillis();\n                }\n                Connection result = null;\n                if(!pool.isEmpty()){\n                    result = pool.removeFirst();\n                }\n                return result;\n            }\n        }\n    }\n}\n")])])]),t("p",[n._v("由于java.sql.Connection是一个接口，最终的实现是由数据库驱动提供方来实现的，考虑到只是个示例，我们通过动态代理构造了一个Connection，该Connection的代理实现仅仅是在commit()方法调用时休眠100毫秒，示例如代码清单4-17所示。")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v('public class ConnectionDriver {\n    static class ConnectionHandler implements InvocationHandler{\n        @Override\n        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n            if(method.getName().equals("commit")){\n                TimeUnit.MICROSECONDS.sleep(100);\n            }\n            return null;\n        }\n    }\n    // 创建一个Connection的代理，在commit时休眠100毫秒\n    public static final Connection createConnection(){\n        return (Connection)Proxy.newProxyInstance(ConnectionDriver.class.getClassLoader(), \n                new Class[]{Connection.class}, new ConnectionHandler());\n    }\n}\n')])])]),t("p",[n._v("下面通过一个示例来测试简易数据库连接池的工作情况，模拟客户端ConnectionRunner获取、使用、最后释放连接的过程，当它使用时连接将会增加获取到连接的数量，反之，将会增加未获取到连接的数量，示例如代码清单4-18所示。")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v('public class ConnectionPoolTest {\n    static ConnectionPool pool = new ConnectionPool(10);\n    // 保证所有ConnectionRunner能够同时开始\n    static CountDownLatch start = new CountDownLatch(1);\n    // main线程将会等待所有ConnectionRunner结束后才能继续执行\n    static CountDownLatch end;\n    public static void main(String[] args) throws InterruptedException {\n        // 线程数量，可以修改线程数量进行观察\n        int threadCount =10;\n        end = new CountDownLatch(threadCount);\n        int count = 20;\n        AtomicInteger got = new AtomicInteger();\n        AtomicInteger notGot = new AtomicInteger();\n        for (int i = 0; i < threadCount; i++) {\n            Thread thread = new Thread(new ConnetionRunner(count, got, notGot),"ConnectionRunnerThread");\n            thread.start();\n        }\n        start.countDown();\n        end.await();\n        System.out.println("total invoke: "+(threadCount * count));\n        System.out.println("got connection: "+got);\n        System.out.println("not got connection "+notGot);\n    }\n    \n    static class ConnetionRunner implements Runnable{\n        int count;\n        AtomicInteger got;\n        AtomicInteger notGot;\n        public ConnetionRunner(int count,AtomicInteger got,AtomicInteger notGot) {\n            this.count = count;\n            this.got = got;\n            this.notGot = notGot;\n        }\n        \n        @Override\n        public void run() {\n            try {\n                start.await();\n            } catch (Exception e) {\n            }\n            while(count>0){\n                try {\n                    // 从线程池中获取连接，如果1000ms内无法获取到，将会返回null\n                    // 分别统计连接获取的数量got和未获取到的数量notGot\n                    Connection connection = pool.fetchConnection(1000);\n                    if(connection !=null){\n                        try {\n                            connection.createStatement();\n                            connection.commit();\n                        } finally {\n                            pool.releaseConnection(connection);\n                            got.incrementAndGet();\n                        }\n                    }else{\n                        notGot.incrementAndGet();\n                    }\n                } catch(Exception e) {\n                }finally {\n                    count--;\n                }\n            }\n            end.countDown();\n        }\n    }\n}\n')])])]),t("h3",{attrs:{id:"线程池技术及其示例"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#线程池技术及其示例"}},[n._v("#")]),n._v(" 线程池技术及其示例")]),n._v(" "),t("p",[n._v("对于服务端的程序，经常面对的是客户端传入的短小（执行时间短、工作内容较为单一）任务，需要服务端快速处理并返回结果。如果服务端每次接受到一个任务，创建一个线程，然后进行执行，这在原型阶段是个不错的选择，但是面对成千上万的任务递交进服务器时，如果还是采用一个任务一个线程的方式，那么将会创建数以万记的线程，这不是一个好的选择。因为这会使操作系统频繁的进行线程上下文切换，无故增加系统的负载，而线程的创建和消亡都是需要耗费系统资源的，也无疑浪费了系统资源。")]),n._v(" "),t("p",[n._v("线程池技术能够很好地解决这个问题，它预先创建了若干数量的线程，并且不能由用户直接对线程的创建进行控制，在这个前提下重复使用固定或较为固定数目的线程来完成任务的执行。这样做的好处是，一方面，消除了频繁创建和消亡线程的系统资源开销，另一方面，面对过量任务的提交能够平缓的劣化。")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("public interface ThreadPool<Job extends Runnable> {\n    // 执行一个Job，这个Job需要实现Runnable\n    void execute(Job job);\n    // 关闭线程池\n    void shutdown();\n    // 增加工作者线程\n    void addWorkers(int num);\n    // 减少工作者线程\n    void removeWorker(int num);\n    // 得到正在等待执行的任务数量\n    int getJobSize();\n}\n")])])]),t("p",[n._v("客户端可以通过execute(Job)方法将Job提交入线程池执行，而客户端自身不用等待Job的执行完成。除了execute(Job)方法以外，线程池接口提供了增大/减少工作者线程以及关闭线程池的方法。这里工作者线程代表着一个重复执行Job的线程，而每个由客户端提交的Job都将进入到一个工作队列中等待工作者线程的处理。")])])}),[],!1,null,null,null);e.default=i.exports}}]);