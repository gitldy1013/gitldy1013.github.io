(window.webpackJsonp=window.webpackJsonp||[]).push([[731],{1428:function(t,s,e){"use strict";e.r(s);var i=e(5),n=Object(i.a)({},(function(){var t=this.$createElement,s=this._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":this.$parent.slotKey}},[s("h1",{attrs:{id:"缓存崩溃"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#缓存崩溃"}},[this._v("#")]),this._v(" 缓存崩溃")]),this._v(" "),s("ul",[s("li",[this._v("碰到这种情况，一般并发量不是特别多的时候，使用最多的解决方案是加锁排队。")]),this._v(" "),s("li",[this._v("加锁排队只是为了减轻数据库的压力，并没有提高系统吞吐量。假设在高并发下，缓存重建期间 key 是锁着的，这时过来 1000 个请求 999 个都在阻塞的。同样会导致用户等待超时，这是个治标不治本的方法。")])])])}),[],!1,null,null,null);s.default=n.exports}}]);