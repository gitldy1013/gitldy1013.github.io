(window.webpackJsonp=window.webpackJsonp||[]).push([[110],{807:function(t,s,e){"use strict";e.r(s);var i=e(5),a=Object(i.a)({},(function(){var t=this,s=t.$createElement,e=t._self._c||s;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"前言"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[t._v("#")]),t._v(" 前言")]),t._v(" "),e("p",[t._v("Java 泛型（Generic）的引入加强了参数类型的安全性，减少了类型的转换，但有一点需要注意：Java 的泛型在编译器有效，在运行期被删除，也就是说所有泛型参数类型在编译后都会被清除掉，看下面一个列子，代码如下：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("public class Foo {\n    public void listMethod(List<String> stringList){\n    }\n    public void listMethod(List<Integer> intList) {\n    }\n}\n")])])]),e("p",[t._v("代码很简单，看起来没什么问题，但是编译器却报出如下错误信息：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("Method listMethod(List<String>) has the same erasure listMethod(List<E>) as another method in type Foo\n")])])]),e("p",[t._v("此错误的意思是说listMethod(List"),e("String",[t._v(") 方法在编译时擦除类型后的方法是listMethod(List"),e("E",[t._v(")，它与另外一个方法重复，也就是方法签名重复。反编译之后的方法代码如下：")])],1)],1),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("public void listMethod(List list){\n}\n")])])]),e("p",[t._v("从上面代码可以看出 Java 编译后的字节码中已经没有泛型的任何信息，在编译后所有的泛型类型都会做相应的转化，转化如下：")]),t._v(" "),e("ul",[e("li",[t._v("List"),e("String",[t._v("、List"),e("T",[t._v(" 擦除后的类型为 List。")])],1)],1),t._v(" "),e("li",[t._v("List"),e("String",[t._v("、List"),e("T",[t._v("[] 擦除后的类型为 List[]。")])],1)],1),t._v(" "),e("li",[t._v("List<? extends E>、List<? super E> 擦除后的类型为 List"),e("E",[t._v("。")])],1),t._v(" "),e("li",[t._v("List<T extends Serialzable & Cloneable> 擦除后类型为 List"),e("Serializable",[t._v("。")])],1)]),t._v(" "),e("p",[t._v("Java 为什么这么处理呢？有以下两个原因：")]),t._v(" "),e("p",[t._v("避免 JVM 的大换血。如果 JVM 将泛型类型延续到运行期，那么到运行期时 JVM 就需要进行大量的重构工作了，提高了运行期的效率。"),e("br"),t._v("\n版本兼容。 在编译期擦除可以更好地支持原生类型（Raw Type）。")]),t._v(" "),e("p",[t._v("明白了 Java 泛型是类型擦除的，下面的问题就很好理解了：")]),t._v(" "),e("h2",{attrs:{id:"泛型的-class-对象是相同的"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#泛型的-class-对象是相同的"}},[t._v("#")]),t._v(" 泛型的 class 对象是相同的")]),t._v(" "),e("p",[t._v("每个类都有一个 class 属性，泛型化不会改变 class 属性的返回值，例如：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("public static void main(String[] args) {\n\tList<String> ls = new ArrayList<String>();\n\tList<Integer> li = new ArrayList<Integer>();\n\tSystem.out.println(ls.getClass() == li.getClass());\n}\n")])])]),e("p",[t._v("代码返回值为 true，原因很简单，List"),e("String",[t._v(" 和 List"),e("Integer",[t._v(" 擦除后的类型都是 List。")])],1)],1),t._v(" "),e("h2",{attrs:{id:"泛型数组初始化时不能声明泛型类型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#泛型数组初始化时不能声明泛型类型"}},[t._v("#")]),t._v(" 泛型数组初始化时不能声明泛型类型")]),t._v(" "),e("p",[t._v("如下代码编译时通不过：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("List<String>[] list = new List<String>[];\n")])])]),e("p",[t._v("在这里可以声明一个带有泛型参数的数组，但是不能初始化该数组，因为执行了类型擦除操作后，List"),e("Object",[t._v("[] 与 List"),e("String",[t._v("[] 就是同一回事了，编译器拒绝如此声明。")])],1)],1),t._v(" "),e("h2",{attrs:{id:"instanceof-不允许存在泛型参数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#instanceof-不允许存在泛型参数"}},[t._v("#")]),t._v(" instanceof 不允许存在泛型参数")]),t._v(" "),e("p",[t._v("以下代码不能通过编译，原因一样，泛型类型被擦除了。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("List<String> list = new ArrayList<String>();\nSystem.out.println(list instanceof List<String>);\n")])])]),e("p",[t._v("错误信息如下："),e("br"),t._v("\nCannot perform instanceof check against parameterized type List"),e("String",[t._v(". Use the form List<?> instead since further generic type information will be erased at runtime")])],1),t._v(" "),e("h2",{attrs:{id:"类型擦除"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#类型擦除"}},[t._v("#")]),t._v(" 类型擦除")]),t._v(" "),e("p",[t._v("正确理解泛型概念的首要前提是理解类型擦除（type erasure）。 Java中的泛型基本上都是在编译器这个层次来实现的。在生成的Java字节代码中是不包含泛型中的类型信息的。使用泛型的时候加上的类型参数，会被编译器在编译的时候去掉。这个过程就称为类型擦除。如在代码中定义的List"),e("Object",[t._v("和List"),e("String",[t._v("等类型，在编译之后都会变成List。JVM看到的只是List，而由泛型附加的类型信息对JVM来说是不可见的。Java编译器会在编译时尽可能的发现可能出错的地方，但是仍然无法避免在运行时刻出现类型转换异常的情况。类型擦除也是Java的泛型实现方式与"),e("a",{attrs:{href:"http://www.cplusplus.com/doc/tutorial/templates/",target:"_blank",rel:"noopener noreferrer"}},[t._v("C++模板机制"),e("OutboundLink")],1),t._v("实现方式之间的重要区别。")])],1)],1),t._v(" "),e("p",[t._v("很多泛型的奇怪特性都与这个类型擦除的存在有关，包括：")]),t._v(" "),e("ul",[e("li",[t._v("泛型类并没有自己独有的Class类对象。比如并不存在List"),e("String",[t._v(".class或是List"),e("Integer",[t._v(".class，而只有List.class。")])],1)],1),t._v(" "),e("li",[t._v("静态变量是被泛型类的所有实例所共享的。对于声明为MyClass"),e("T",[t._v("的类，访问其中的静态变量的方法仍然是 MyClass.myStaticVar。不管是通过new MyClass"),e("String",[t._v("还是new MyClass"),e("Integer",[t._v("创建的对象，都是共享一个静态变量。")])],1)],1)],1),t._v(" "),e("li",[t._v("泛型的类型参数不能用在Java异常处理的catch语句中。因为异常处理是由JVM在运行时刻来进行的。由于类型信息被擦除，JVM是无法区分两个异常类型MyException"),e("String",[t._v("和MyException"),e("Integer",[t._v("的。对于JVM来说，它们都是 MyException类型的。也就无法执行与异常对应的catch语句。")])],1)],1)]),t._v(" "),e("p",[t._v("类型擦除的基本过程也比较简单，首先是找到用来替换类型参数的具体类。这个具体类一般是Object。如果指定了类型参数的上界的话，则使用这个上界。把代码中的类型参数都替换成具体的类。同时去掉出现的类型声明，即去掉<>的内容。比如T get()方法声明就变成了Object get()；List"),e("String",[t._v("就变成了List。接下来就可能需要生成一些桥接方法（bridge method）。这是由于擦除了类型之后的类可能缺少某些必须的方法。比如考虑下面的代码：")])],1),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("class MyString implements Comparable<String> {\n    public int compareTo(String str) {        \n        return 0;    \n    }\n} \n")])])]),e("p",[t._v("当类型信息被擦除之后，上述类的声明变成了class MyString implements Comparable。但是这样的话，类MyString就会有编译错误，因为没有实现接口Comparable声明的String compareTo(Object)方法。这个时候就由编译器来动态生成这个方法。")]),t._v(" "),e("h4",{attrs:{id:"实例分析"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#实例分析"}},[t._v("#")]),t._v(" 实例分析")]),t._v(" "),e("p",[t._v("了解了类型擦除机制之后，就会明白编译器承担了全部的类型检查工作。编译器禁止某些泛型的使用方式，正是为了确保类型的安全性。以上面提到的List"),e("Object",[t._v("和List"),e("String",[t._v("为例来具体分析：")])],1)],1),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("public void inspect(List<Object> list) {    \n    for (Object obj : list) {        \n        System.out.println(obj);    \n    }    \n    list.add(1); //这个操作在当前方法的上下文是合法的。 \n}\npublic void test() {    \n    List<String> strs = new ArrayList<String>();    \n    inspect(strs); //编译错误 \n}\n")])])]),e("p",[t._v("这段代码中，inspect方法接受List"),e("Object",[t._v("作为参数，当在test方法中试图传入List"),e("String",[t._v("的时候，会出现编译错误。假设这样的做法是允许的，那么在inspect方法就可以通过list.add(1)来向集合中添加一个数字。这样在test方法看来，其声明为List"),e("String",[t._v("的集合中却被添加了一个Integer类型的对象。这显然是违反类型安全的原则的，在某个时候肯定会抛出"),e("a",{attrs:{href:"http://download.oracle.com/javase/1.5.0/docs/api/java/lang/ClassCastException.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("ClassCastException"),e("OutboundLink")],1),t._v("。因此，编译器禁止这样的行为。编译器会尽可能的检查可能存在的类型安全问题。对于确定是违反相关原则的地方，会给出编译错误。当编译器无法判断类型的使用是否正确的时候，会给出警告信息。")])],1)],1)],1),t._v(" "),e("h4",{attrs:{id:"通配符与上下界"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#通配符与上下界"}},[t._v("#")]),t._v(" 通配符与上下界")]),t._v(" "),e("p",[t._v("在使用泛型类的时候，既可以指定一个具体的类型，如List"),e("String",[t._v("就声明了具体的类型是String；也可以用通配符?来表示未知类型，如List<?>就声明了List中包含的元素类型是未知的。 通配符所代表的其实是一组类型，但具体的类型是未知的。List<?>所声明的就是所有类型都是可以的。但是List<?>并不等同于List"),e("Object",[t._v("。List"),e("Object",[t._v("实际上确定了List中包含的是Object及其子类，在使用的时候都可以通过Object来进行引用。而List<?>则其中所包含的元素类型是不确定。其中可能包含的是String，也可能是 Integer。如果它包含了String的话，往里面添加Integer类型的元素就是错误的。正因为类型未知，就不能通过new ArrayList<?>()的方法来创建一个新的ArrayList对象。因为编译器无法知道具体的类型是什么。但是对于 List<?>中的元素确总是可以用Object来引用的，因为虽然类型未知，但肯定是Object及其子类。考虑下面的代码：")])],1)],1)],1),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("public void wildcard(List<?> list) {\n    list.add(1);//编译错误 \n} \n")])])]),e("p",[t._v("如上所示，试图对一个带通配符的泛型类进行操作的时候，总是会出现编译错误。其原因在于通配符所表示的类型是未知的。")]),t._v(" "),e("p",[t._v("因为对于List<?>中的元素只能用Object来引用，在有些情况下不是很方便。在这些情况下，可以使用上下界来限制未知类型的范围。 如List<? extends Number>说明List中可能包含的元素类型是Number及其子类。而List<? super Number>则说明List中包含的是Number及其父类。当引入了上界之后，在使用类型的时候就可以使用上界类中定义的方法。比如访问 List<? extends Number>的时候，就可以使用Number类的intValue等方法。")]),t._v(" "),e("h4",{attrs:{id:"类型系统"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#类型系统"}},[t._v("#")]),t._v(" 类型系统")]),t._v(" "),e("p",[t._v("在Java中，大家比较熟悉的是通过继承机制而产生的类型体系结构。比如String继承自Object。根据"),e("a",{attrs:{href:"http://en.wikipedia.org/wiki/Liskov_substitution_principle",target:"_blank",rel:"noopener noreferrer"}},[t._v("Liskov替换原则"),e("OutboundLink")],1),t._v("，子类是可以替换父类的。当需要Object类的引用的时候，如果传入一个String对象是没有任何问题的。但是反过来的话，即用父类的引用替换子类引用的时候，就需要进行强制类型转换。编译器并不能保证运行时刻这种转换一定是合法的。这种自动的子类替换父类的类型转换机制，对于数组也是适用的。 String[]可以替换Object[]。但是泛型的引入，对于这个类型系统产生了一定的影响。正如前面提到的List"),e("String",[t._v("是不能替换掉List"),e("Object",[t._v("的。")])],1)],1),t._v(" "),e("p",[t._v("引入泛型之后的类型系统增加了两个维度：一个是类型参数自身的继承体系结构，另外一个是泛型类或接口自身的继承体系结构。第一个指的是对于 List"),e("String",[t._v("和List"),e("Object",[t._v("这样的情况，类型参数String是继承自Object的。而第二种指的是 List接口继承自Collection接口。对于这个类型系统，有如下的一些规则：")])],1)],1),t._v(" "),e("ul",[e("li",[t._v("相同类型参数的泛型类的关系取决于泛型类自身的继承体系结构。即List"),e("String",[t._v("是Collection"),e("String",[t._v(" 的子类型，List"),e("String",[t._v("可以替换Collection"),e("String",[t._v("。这种情况也适用于带有上下界的类型声明。")])],1)],1)],1)],1),t._v(" "),e("li",[t._v("当泛型类的类型声明中使用了通配符的时候， 其子类型可以在两个维度上分别展开。如对Collection<? extends Number>来说，其子类型可以在Collection这个维度上展开，即List<? extends Number>和Set<? extends Number>等；也可以在Number这个层次上展开，即Collection"),e("Double",[t._v("和 Collection"),e("Integer",[t._v("等。如此循环下去，ArrayList"),e("Long",[t._v("和 HashSet"),e("Double",[t._v("等也都算是Collection<? extends Number>的子类型。")])],1)],1)],1)],1),t._v(" "),e("li",[t._v("如果泛型类中包含多个类型参数，则对于每个类型参数分别应用上面的规则。")])]),t._v(" "),e("p",[t._v("理解了上面的规则之后，就可以很容易的修正实例分析中给出的代码了。只需要把List"),e("Object",[t._v("改成List<?>即可。List"),e("String",[t._v("是List<?>的子类型，因此传递参数时不会发生错误。")])],1)],1),t._v(" "),e("h4",{attrs:{id:"开发自己的泛型类"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#开发自己的泛型类"}},[t._v("#")]),t._v(" 开发自己的泛型类")]),t._v(" "),e("p",[t._v("泛型类与一般的Java类基本相同，只是在类和接口定义上多出来了用<>声明的类型参数。一个类可以有多个类型参数，如 MyClass<X, Y, Z>。 每个类型参数在声明的时候可以指定上界。所声明的类型参数在Java类中可以像一般的类型一样作为方法的参数和返回值，或是作为域和局部变量的类型。但是由于类型擦除机制，类型参数并不能用来创建对象或是作为静态变量的类型。考虑下面的泛型类中的正确和错误的用法。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("class ClassTest<X extends Number, Y, Z> {    \n    private X x;    \n    private static Y y; //编译错误，不能用在静态变量中    \n    public X getFirst() {\n        //正确用法        \n        return x;    \n    }    \n    public void wrong() {        \n        Z z = new Z(); //编译错误，不能创建对象    \n    }\n}\n")])])]),e("h4",{attrs:{id:"泛型传递"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#泛型传递"}},[t._v("#")]),t._v(" 泛型传递")]),t._v(" "),e("p",[t._v("即泛型可以当作参数在不同的实例化的类中传递，理论上来说可以无限制层次的传递下去。最终会约束每一层的方法或者类型的泛型确定，在《"),e("a",{attrs:{href:"http://www.raychase.net/2446",target:"_blank",rel:"noopener noreferrer"}},[t._v("泛型传递"),e("OutboundLink")],1),t._v("》这篇文章中对具体的用法进行详尽的描述。")]),t._v(" "),e("h4",{attrs:{id:"最佳实践"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#最佳实践"}},[t._v("#")]),t._v(" 最佳实践")]),t._v(" "),e("p",[t._v("在使用泛型的时候可以遵循一些基本的原则，从而避免一些常见的问题。")]),t._v(" "),e("ul",[e("li",[t._v("在代码中避免泛型类和原始类型的混用。比如List"),e("String",[t._v("和List不应该共同使用。这样会产生一些编译器警告和潜在的运行时异常。当需要利用JDK 5之前开发的遗留代码，而不得不这么做时，也尽可能的隔离相关的代码。")])],1),t._v(" "),e("li",[t._v("在使用带通配符的泛型类的时候，需要明确通配符所代表的一组类型的概念。由于具体的类型是未知的，很多操作是不允许的。")]),t._v(" "),e("li",[t._v("泛型类最好不要同数组一块使用。你只能创建new List<?>[10]这样的数组，无法创建new List"),e("String",[t._v("[10]这样的。这限制了数组的使用能力，而且会带来很多费解的问题。因此，当需要类似数组的功能时候，使用集合类即可。")])],1),t._v(" "),e("li",[t._v("不要忽视编译器给出的警告信息。")])])])}),[],!1,null,null,null);s.default=a.exports}}]);