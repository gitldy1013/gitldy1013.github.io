(window.webpackJsonp=window.webpackJsonp||[]).push([[342],{1039:function(t,a,s){"use strict";s.r(a);var v=s(5),_=Object(v.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"http和https"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#http和https"}},[t._v("#")]),t._v(" http和https")]),t._v(" "),s("h2",{attrs:{id:"http"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#http"}},[t._v("#")]),t._v(" http")]),t._v(" "),s("p",[t._v("http是一种无状态协议。无状态是指客户机和服务器之间不需要建立持久连接，这意味着当一个客户端向服务器发出请求，然后服务器返回响应（response），连接就被关闭了，在服务器端不保留连接的有关信息，HTTP遵循请求/应答模型。客户机向服务器发送请求，服务器处理请求并返回适当的应答。所有HTTP连接都构成一套请求和应答。")]),t._v(" "),s("h2",{attrs:{id:"https"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#https"}},[t._v("#")]),t._v(" https")]),t._v(" "),s("p",[t._v("HTTPS是以安全为目标的HTTP通道，简单将就是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL。其所用的端口是443，过程大致如下：")]),t._v(" "),s("h3",{attrs:{id:"获取连接证书"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#获取连接证书"}},[t._v("#")]),t._v(" 获取连接证书")]),t._v(" "),s("p",[t._v("SSL客户端通过TCP和服务器建立连接后（443端口），并且在一般的TCP连接协商过程中请求证书。即客户端发出一个消息给服务器，这个消息里面包含了自己可实现的算法列表和其它一些需要的消息，SSL的服务器端会回应一个数据包，这里面确定了这次通信所需要的算法，然后服务器向客户端返回证书。（证书里面包含了服务器信息：域名。申请证书的公司，公共密钥）")]),t._v(" "),s("h3",{attrs:{id:"证书验证"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#证书验证"}},[t._v("#")]),t._v(" 证书验证")]),t._v(" "),s("p",[t._v("客户端在收到服务器返回的证书后，判断签发这个证书的公共签发机构，并使用这个机构的公共密钥确认签名是否有效，客户端还会确保证书中列出的域名就是它正在连接的域名")]),t._v(" "),s("h3",{attrs:{id:"数据加密和传输"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#数据加密和传输"}},[t._v("#")]),t._v(" 数据加密和传输")]),t._v(" "),s("p",[t._v("如果确认证书有效，那么生成对称密钥并使用服务器的公共密钥进行加密。然后发送给服务器，服务器使用它的密钥进行解密，这样两台计算机可以开始进行对称加密进行通信。")]),t._v(" "),s("p",[s("img",{attrs:{src:"/images/image-20200413085448943.png",alt:"image-20200413085448943"}})]),t._v(" "),s("p",[t._v("对称加密：是指加密和解密用的都是同一个密钥，目前微信小程序采用的就是这个加密方式")]),t._v(" "),s("h3",{attrs:{id:"对称加密存在的问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#对称加密存在的问题"}},[t._v("#")]),t._v(" 对称加密存在的问题")]),t._v(" "),s("p",[t._v("首先我们知道对称加密是指：加密和解密都使用的同一个密钥，这种方式存在的最大的问题就是密钥发送问题，即如果安全的将密钥发送给对方。")]),t._v(" "),s("h4",{attrs:{id:"为什么叫对称加密"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#为什么叫对称加密"}},[t._v("#")]),t._v(" 为什么叫对称加密？")]),t._v(" "),s("p",[t._v("一方通过密钥将信息加密后，把密文传给另一个方，另一方通过这个相同的密钥将密文解密，转换成可以理解的明文。他们之间的关系如下")]),t._v(" "),s("blockquote",[s("p",[t._v("明文 -> 密钥 -> 密文")])]),t._v(" "),s("p",[t._v("但是从上面的图我们可以看出，我们在进行加密后，首先需要将密钥发送给服务器，那么这个过程就可能存在危险的")]),t._v(" "),s("p",[s("img",{attrs:{src:"/images/image-20200413091318404.png",alt:"image-20200413091318404"}})]),t._v(" "),s("h3",{attrs:{id:"非对称加密"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#非对称加密"}},[t._v("#")]),t._v(" 非对称加密")]),t._v(" "),s("p",[t._v("上面提到的是对称加密，其实还有一种是非对称加密，非对称加密是通过两个密钥（公钥 - 私钥）来实现对数据的加密和解密的，公钥用于加密，私钥用于解密。")]),t._v(" "),s("p",[s("img",{attrs:{src:"/images/image-20200413085937800.png",alt:"image-20200413085937800"}})]),t._v(" "),s("p",[t._v("过程如下：")]),t._v(" "),s("p",[t._v("首先服务器会颁发一个公钥放在网络中，同时它自己还有一份私钥，然后客户端可以直接获取到对应的公钥")]),t._v(" "),s("p",[t._v("然后将客户端的数据进行公钥的加密，加密后传输的服务器中，服务器在进行私钥解密，得到最终的数据")]),t._v(" "),s("p",[s("img",{attrs:{src:"/images/image-20200413102124070.png",alt:"image-20200413102124070"}})]),t._v(" "),s("p",[t._v("由于非对称加密的方式不需要发送用来解密的私钥，所以可以保证安全性，但是和对称加密比起来，它非常慢，所以我们还是要用对称加密来传送消息，但是对称加密使用的密钥我们通过非对称加密的方式发送出去。这个结果就变成了：")]),t._v(" "),s("p",[s("img",{attrs:{src:"/images/image-20200413102622594.png",alt:"image-20200413102622594"}})]),t._v(" "),s("p",[t._v("但是我们需要注意的是，此时交换的两个公钥不一定正确，因为可能会被中间人截获，同时掉包")]),t._v(" "),s("p",[t._v("例如：中间人虽然不知道小红的私钥是什么，但是在截获了小红的公钥Key1之后，却可以偷天换日，自己另外生成一对公钥私钥，把自己的公钥Key3发送给小灰。")]),t._v(" "),s("p",[s("img",{attrs:{src:"/images/image-20200413102718466.png",alt:"image-20200413102718466"}})]),t._v(" "),s("p",[t._v("这一次通信再次被中间人截获，中间人先用自己的私钥解开了Key3的加密，获得Key2，然后再用当初小红发来的Key1重新加密，再发给小红")]),t._v(" "),s("p",[s("img",{attrs:{src:"/images/image-20200413102738635.png",alt:"image-20200413102738635"}})]),t._v(" "),s("h3",{attrs:{id:"证书机制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#证书机制"}},[t._v("#")]),t._v(" 证书机制")]),t._v(" "),s("p",[t._v("这个时候我们需要做的就是从指定的机构出获取公钥，而不是任由其在网络传输")]),t._v(" "),s("ul",[s("li",[t._v("作为服务器端的小红，首先先把自己的公钥给证书颁发机构，向证书颁发机构申请证书")]),t._v(" "),s("li",[t._v("证书颁发机构自己也有一堆公钥和私钥。机构利用自己的私钥来解密Key1，通过服务端网址等信息生成一个证书签名，证书签名同样经过机构的私钥加密。证书制作完成后，机构把证书发送给服务端的小红。")]),t._v(" "),s("li",[t._v("当小灰向小红请求通信的时候，小红不再直接返回自己的公钥，而是把自己申请的证书返回给小灰。")]),t._v(" "),s("li",[t._v("小灰收到证书以后，要做的第一件事就是验证证书的真伪，需要说明的是，各大浏览器和操作系统已经维护了所有权威证书机构的名称和公钥，所以小灰只需要知道是哪个机构颁发的证书，就可以从本地找到对应的机构公钥，解密出证书签名。")])]),t._v(" "),s("p",[s("img",{attrs:{src:"/images/image-20200413103251089.png",alt:"image-20200413103251089"}})]),t._v(" "),s("h2",{attrs:{id:"参考"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[t._v("#")]),t._v(" 参考")]),t._v(" "),s("p",[t._v("https://blog.csdn.net/jiangshangchunjiezi/article/details/88545263")])])}),[],!1,null,null,null);a.default=_.exports}}]);