(window.webpackJsonp=window.webpackJsonp||[]).push([[674],{1371:function(o,v,c){"use strict";c.r(v);var n=c(5),_=Object(n.a)({},(function(){var o=this,v=o.$createElement,c=o._self._c||v;return c("ContentSlotsDistributor",{attrs:{"slot-key":o.$parent.slotKey}},[c("h1",{attrs:{id:"synchronized-与-lock-的区别"}},[c("a",{staticClass:"header-anchor",attrs:{href:"#synchronized-与-lock-的区别"}},[o._v("#")]),o._v(" synchronized 与 lock 的区别")]),o._v(" "),c("ul",[c("li",[c("p",[o._v("synchronized 和 lock 的用法区别")]),o._v(" "),c("ul",[c("li",[o._v("synchronized(隐式锁)：在需要同步的对象中加入此控制，"),c("code",[o._v("synchronized")]),o._v(" 可以加在方法上，也可以加在特定代码块中，括号中表示需要锁的对象。")]),o._v(" "),c("li",[o._v("lock（显示锁）：需要显示指定起始位置和终止位置。一般使用 "),c("code",[o._v("ReentrantLock")]),o._v(" 类做为锁，多个线程中必须要使用一个 "),c("code",[o._v("ReentrantLock")]),o._v(" 类做为对象才能保证锁的生效。且在加锁和解锁处需要通过 "),c("code",[o._v("lock()")]),o._v(" 和 "),c("code",[o._v("unlock()")]),o._v(" 显示指出。所以一般会在 "),c("code",[o._v("finally")]),o._v(" 块中写 "),c("code",[o._v("unlock()")]),o._v(" 以防死锁。")])])]),o._v(" "),c("li",[c("p",[o._v("synchronized 和 lock 性能区别 "),c("code",[o._v("synchronized")]),o._v(" 是托管给 JVM 执行的，而 "),c("code",[o._v("lock")]),o._v(" 是 Java 写的控制锁的代码。在 "),c("strong",[o._v("JDK 1.5")]),o._v(" 中，"),c("code",[o._v("synchronize")]),o._v(" 是性能低效的。因为这是一个重量级操作，需要调用操作接口，导致有可能加锁消耗的系统时间比加锁以外的操作还多。相比之下使用 Java 提供的 "),c("code",[o._v("Lock")]),o._v(" 对象，性能更高一些。但是到了 "),c("strong",[o._v("JDK 1.6")]),o._v("，发生了变化。"),c("code",[o._v("synchronize")]),o._v(" 在语义上很清晰，可以进行很多优化，有适应自旋，锁消除，锁粗化，轻量级锁，偏向锁等等。导致在 "),c("strong",[o._v("JDK 1.6")]),o._v(" 上 "),c("code",[o._v("synchronize")]),o._v(" 的性能并不比 "),c("code",[o._v("Lock")]),o._v(" 差。")])]),o._v(" "),c("li",[c("p",[o._v("synchronized 和 lock 机制区别")]),o._v(" "),c("ul",[c("li",[c("code",[o._v("synchronized")]),o._v(" 原始采用的是 CPU 悲观锁机制，即线程获得的是独占锁。独占锁意味着其 他线程只能依靠阻塞来等待线程释放锁。")]),o._v(" "),c("li",[c("code",[o._v("Lock")]),o._v(" 用的是乐观锁方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。乐观锁实现的机制就是 CAS 操作（Compare and Swap）。")])])])])])}),[],!1,null,null,null);v.default=_.exports}}]);